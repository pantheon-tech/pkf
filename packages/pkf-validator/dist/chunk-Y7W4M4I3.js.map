{"version":3,"sources":["../src/types/index.ts","../src/validators/config-validator.ts","../src/utils/file-utils.ts","../src/utils/schema-utils.ts","../src/validators/todo-validator.ts","../src/validators/issue-validator.ts","../src/validators/changelog-validator.ts","../src/validators/frontmatter-validator.ts","../src/parsers/schema-dsl-parser.ts","../src/index.ts"],"sourcesContent":["/**\r\n * PKF Validator Types\r\n * Core type definitions for validation results and errors\r\n */\r\n\r\n/**\r\n * Severity level for validation issues\r\n */\r\nexport type Severity = 'error' | 'warning' | 'info';\r\n\r\n/**\r\n * A single validation error or warning\r\n */\r\nexport interface ValidationIssue {\r\n  /** Unique error code for programmatic handling */\r\n  code: string;\r\n  /** Human-readable error message */\r\n  message: string;\r\n  /** Severity level */\r\n  severity: Severity;\r\n  /** File path where the issue was found */\r\n  filePath?: string;\r\n  /** Line number (1-based) where the issue was found */\r\n  line?: number;\r\n  /** Column number (1-based) where the issue was found */\r\n  column?: number;\r\n  /** The problematic value */\r\n  value?: unknown;\r\n  /** Expected value or pattern */\r\n  expected?: unknown;\r\n  /** Suggestion for how to fix the issue */\r\n  suggestion?: string;\r\n}\r\n\r\n/**\r\n * Result of a validation operation\r\n */\r\nexport interface ValidationResult {\r\n  /** Whether the validation passed (no errors) */\r\n  valid: boolean;\r\n  /** List of errors found */\r\n  errors: ValidationIssue[];\r\n  /** List of warnings found */\r\n  warnings: ValidationIssue[];\r\n  /** List of informational messages */\r\n  info: ValidationIssue[];\r\n  /** Time taken for validation in milliseconds */\r\n  duration?: number;\r\n  /** Number of items validated */\r\n  itemCount?: number;\r\n}\r\n\r\n/**\r\n * Options for validation operations\r\n */\r\nexport interface ValidationOptions {\r\n  /** Root directory for resolving paths */\r\n  rootDir?: string;\r\n  /** Whether to include warnings */\r\n  includeWarnings?: boolean;\r\n  /** Whether to include info messages */\r\n  includeInfo?: boolean;\r\n  /** Maximum number of errors before stopping */\r\n  maxErrors?: number;\r\n  /** Whether to validate in strict mode */\r\n  strict?: boolean;\r\n}\r\n\r\n/**\r\n * PKF Configuration structure\r\n */\r\nexport interface PkfConfig {\r\n  version: string;\r\n  project: {\r\n    name: string;\r\n    version?: string;\r\n    description?: string;\r\n  };\r\n  structure: {\r\n    root: string;\r\n    registers?: string;\r\n    architecture?: string;\r\n    guides?: string;\r\n    templates?: string;\r\n  };\r\n  schemas?: {\r\n    path?: string;\r\n    documentTypes?: Record<string, unknown>;\r\n  };\r\n  validation?: {\r\n    frontmatter?: boolean;\r\n    links?: boolean;\r\n    prose?: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * TODO item structure from TODO.md\r\n */\r\nexport interface TodoItem {\r\n  id: string;\r\n  title: string;\r\n  status: 'pending' | 'in-progress' | 'completed' | 'blocked';\r\n  priority?: 'critical' | 'high' | 'medium' | 'low';\r\n  created?: string;\r\n  updated?: string;\r\n  due_date?: string;\r\n  assignee?: string;\r\n  labels?: string[];\r\n  description?: string;\r\n  blockedBy?: string;\r\n}\r\n\r\n/**\r\n * Issue item structure from ISSUES.md\r\n */\r\nexport interface IssueItem {\r\n  id: string;\r\n  title: string;\r\n  status: 'open' | 'investigating' | 'in-progress' | 'resolved' | 'closed';\r\n  severity: 'critical' | 'high' | 'medium' | 'low';\r\n  created?: string;\r\n  updated?: string;\r\n  reporter?: string;\r\n  assignee?: string;\r\n  labels?: string[];\r\n  description?: string;\r\n  resolution?: string;\r\n}\r\n\r\n/**\r\n * Changelog entry structure from CHANGELOG.md\r\n */\r\nexport interface ChangelogEntry {\r\n  version: string;\r\n  date: string;\r\n  changes: {\r\n    type: 'added' | 'changed' | 'deprecated' | 'removed' | 'fixed' | 'security';\r\n    description: string;\r\n  }[];\r\n}\r\n\r\n/**\r\n * Validator interface that all validators must implement\r\n */\r\nexport interface Validator<T = unknown> {\r\n  /** Name of the validator */\r\n  name: string;\r\n  /** Description of what this validator checks */\r\n  description: string;\r\n  /** Validate the given input */\r\n  validate(input: T, options?: ValidationOptions): Promise<ValidationResult>;\r\n}\r\n\r\n/**\r\n * Create an empty validation result\r\n */\r\nexport function createEmptyResult(): ValidationResult {\r\n  return {\r\n    valid: true,\r\n    errors: [],\r\n    warnings: [],\r\n    info: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Create a validation issue\r\n */\r\nexport function createIssue(\r\n  code: string,\r\n  message: string,\r\n  severity: Severity = 'error',\r\n  extra?: Partial<ValidationIssue>\r\n): ValidationIssue {\r\n  return {\r\n    code,\r\n    message,\r\n    severity,\r\n    ...extra,\r\n  };\r\n}\r\n\r\n/**\r\n * Merge multiple validation results into one\r\n */\r\nexport function mergeResults(...results: ValidationResult[]): ValidationResult {\r\n  const merged: ValidationResult = createEmptyResult();\r\n\r\n  for (const result of results) {\r\n    merged.errors.push(...result.errors);\r\n    merged.warnings.push(...result.warnings);\r\n    merged.info.push(...result.info);\r\n    if (result.duration !== undefined) {\r\n      merged.duration = (merged.duration ?? 0) + result.duration;\r\n    }\r\n    if (result.itemCount !== undefined) {\r\n      merged.itemCount = (merged.itemCount ?? 0) + result.itemCount;\r\n    }\r\n  }\r\n\r\n  merged.valid = merged.errors.length === 0;\r\n  return merged;\r\n}\r\n","/**\r\n * PKF Configuration Validator\r\n *\r\n * Validates pkf.config.yaml files against the PKF config schema\r\n * and verifies that referenced directories exist.\r\n */\r\n\r\nimport { join, dirname } from 'path';\r\nimport {\r\n  type ValidationResult,\r\n  type ValidationOptions,\r\n  type ValidationIssue,\r\n  createEmptyResult,\r\n  createIssue,\r\n} from '../types/index.js';\r\nimport {\r\n  fileExists,\r\n  isDirectory,\r\n  readYamlFile,\r\n  readJsonFile,\r\n  getConfigPath,\r\n} from '../utils/file-utils.js';\r\nimport { validateWithSchema } from '../utils/schema-utils.js';\r\n\r\n/**\r\n * Default config file name\r\n */\r\nconst DEFAULT_CONFIG_FILE = 'pkf.config.yaml';\r\n\r\n/**\r\n * Default schema file path (relative to package root)\r\n */\r\nconst DEFAULT_SCHEMA_PATH = 'schemas/pkf-config.schema.json';\r\n\r\n/**\r\n * PKF Configuration structure as defined in the schema\r\n */\r\nexport interface PkfConfigSchema {\r\n  $schema?: string;\r\n  version: string;\r\n  project: {\r\n    name: string;\r\n    version?: string;\r\n    description?: string;\r\n    repository?: string;\r\n  };\r\n  structure?: {\r\n    docsDir?: string;\r\n    archiveDir?: string;\r\n    registersDir?: string;\r\n    templatesDir?: string;\r\n    schemasDir?: string;\r\n    agentsDir?: string;\r\n  };\r\n  registers?: {\r\n    todoFile?: string;\r\n    issuesFile?: string;\r\n    changelogFile?: string;\r\n    idPrefix?: {\r\n      todo?: string;\r\n      issue?: string;\r\n      proposal?: string;\r\n      adr?: string;\r\n    };\r\n    idPadding?: number;\r\n  };\r\n  ai?: {\r\n    enabled?: boolean;\r\n    guidanceFile?: string;\r\n    systemPromptFile?: string;\r\n    customAgents?: boolean;\r\n  };\r\n  packages?: {\r\n    enabled?: boolean;\r\n    directory?: string;\r\n    inheritRules?: boolean;\r\n  };\r\n  validation?: {\r\n    validateSchemas?: boolean;\r\n    validateLinks?: boolean;\r\n    requireNavHubs?: boolean;\r\n  };\r\n  proposals?: {\r\n    enabled?: boolean;\r\n    ranges?: Record<\r\n      string,\r\n      {\r\n        min: number;\r\n        max: number;\r\n        description?: string;\r\n      }\r\n    >;\r\n  };\r\n}\r\n\r\n/**\r\n * Options for config validation\r\n */\r\nexport interface ConfigValidationOptions extends ValidationOptions {\r\n  /** Path to the config file (defaults to pkf.config.yaml in rootDir) */\r\n  configPath?: string;\r\n  /** Path to the schema file (defaults to schemas/pkf-config.schema.json) */\r\n  schemaPath?: string;\r\n  /** Whether to skip directory existence checks */\r\n  skipDirectoryChecks?: boolean;\r\n  /** Whether to check optional directories (only checks configured ones if false) */\r\n  checkOptionalDirectories?: boolean;\r\n}\r\n\r\n/**\r\n * Directory fields in the structure configuration with their defaults\r\n */\r\nconst STRUCTURE_DIRECTORIES = {\r\n  docsDir: 'docs',\r\n  archiveDir: 'docs_archive',\r\n  registersDir: 'docs/registers',\r\n  templatesDir: 'docs/framework/templates',\r\n  schemasDir: 'docs/framework/schemas',\r\n  agentsDir: '.claude/agents',\r\n} as const;\r\n\r\n/**\r\n * Validate a PKF configuration file\r\n *\r\n * @param options - Validation options\r\n * @returns Validation result with errors, warnings, and info messages\r\n */\r\nexport async function validateConfig(\r\n  options: ConfigValidationOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n  const rootDir = options.rootDir ?? process.cwd();\r\n\r\n  // Determine config file path\r\n  const configPath = options.configPath ?? getConfigPath(rootDir);\r\n\r\n  // Check if config file exists\r\n  if (!(await fileExists(configPath))) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'CONFIG_NOT_FOUND',\r\n        `PKF configuration file not found: ${configPath}`,\r\n        'error',\r\n        {\r\n          filePath: configPath,\r\n          suggestion: `Create a pkf.config.yaml file in your project root. You can use the template from templates/pkf-config.template.yaml`,\r\n        }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Load the config file\r\n  let config: PkfConfigSchema;\r\n  try {\r\n    config = await readYamlFile<PkfConfigSchema>(configPath);\r\n  } catch (error) {\r\n    const errorMessage =\r\n      error instanceof Error ? error.message : String(error);\r\n    result.errors.push(\r\n      createIssue(\r\n        'CONFIG_PARSE_ERROR',\r\n        `Failed to parse PKF configuration: ${errorMessage}`,\r\n        'error',\r\n        {\r\n          filePath: configPath,\r\n          suggestion: 'Ensure the file contains valid YAML syntax',\r\n        }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Validate config is not null/undefined\r\n  if (!config || typeof config !== 'object') {\r\n    result.errors.push(\r\n      createIssue(\r\n        'CONFIG_EMPTY',\r\n        'PKF configuration file is empty or invalid',\r\n        'error',\r\n        {\r\n          filePath: configPath,\r\n          suggestion:\r\n            'Add required configuration fields: version and project.name',\r\n        }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Load and validate against JSON schema\r\n  const schemaPath = options.schemaPath ?? findSchemaPath(rootDir);\r\n  if (schemaPath && (await fileExists(schemaPath))) {\r\n    try {\r\n      const schema = await readJsonFile<object>(schemaPath);\r\n      const schemaResult = validateWithSchema<PkfConfigSchema>(\r\n        config,\r\n        schema,\r\n        configPath\r\n      );\r\n\r\n      if (!schemaResult.valid) {\r\n        result.errors.push(...schemaResult.issues);\r\n      }\r\n    } catch (error) {\r\n      const errorMessage =\r\n        error instanceof Error ? error.message : String(error);\r\n      result.warnings.push(\r\n        createIssue(\r\n          'SCHEMA_LOAD_ERROR',\r\n          `Could not load schema for validation: ${errorMessage}`,\r\n          'warning',\r\n          {\r\n            filePath: schemaPath,\r\n            suggestion: 'Ensure the schema file exists and contains valid JSON',\r\n          }\r\n        )\r\n      );\r\n    }\r\n  } else {\r\n    result.info.push(\r\n      createIssue(\r\n        'SCHEMA_NOT_FOUND',\r\n        `Schema file not found at ${schemaPath ?? 'default location'}, performing basic validation only`,\r\n        'info',\r\n        {\r\n          suggestion:\r\n            'Add schemas/pkf-config.schema.json for full schema validation',\r\n        }\r\n      )\r\n    );\r\n\r\n    // Perform basic validation without schema\r\n    const basicErrors = validateBasicConfig(config, configPath);\r\n    result.errors.push(...basicErrors);\r\n  }\r\n\r\n  // Check directory references if schema validation passed\r\n  if (!options.skipDirectoryChecks) {\r\n    const dirIssues = await validateDirectoryReferences(\r\n      config,\r\n      rootDir,\r\n      configPath,\r\n      options.checkOptionalDirectories ?? false\r\n    );\r\n    categorizeIssues(dirIssues, result);\r\n  }\r\n\r\n  // Validate document type definitions if present\r\n  if (config.proposals?.enabled && config.proposals?.ranges) {\r\n    const proposalIssues = validateProposalRanges(\r\n      config.proposals.ranges,\r\n      configPath\r\n    );\r\n    categorizeIssues(proposalIssues, result);\r\n  }\r\n\r\n  // Validate register ID configuration\r\n  if (config.registers?.idPrefix) {\r\n    const registerIssues = validateRegisterConfig(config.registers, configPath);\r\n    categorizeIssues(registerIssues, result);\r\n  }\r\n\r\n  // Set final validity\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n  result.itemCount = 1;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Find the schema path by checking common locations\r\n */\r\nfunction findSchemaPath(rootDir: string): string {\r\n  // Return the primary schema location - actual existence check happens in validateConfig\r\n  return join(rootDir, 'schemas', 'pkf-config.schema.json');\r\n}\r\n\r\n/**\r\n * Perform basic validation when schema is not available\r\n */\r\nfunction validateBasicConfig(\r\n  config: PkfConfigSchema,\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  // Check required fields\r\n  if (!config.version) {\r\n    issues.push(\r\n      createIssue(\r\n        'REQUIRED_FIELD',\r\n        'Missing required field: version',\r\n        'error',\r\n        {\r\n          filePath,\r\n          suggestion: 'Add a version field (e.g., version: \"1.0.0\")',\r\n        }\r\n      )\r\n    );\r\n  } else if (!/^\\d+\\.\\d+\\.\\d+(-[\\w.]+)?$/.test(config.version)) {\r\n    issues.push(\r\n      createIssue(\r\n        'INVALID_VERSION',\r\n        `Invalid version format: ${config.version}`,\r\n        'error',\r\n        {\r\n          filePath,\r\n          value: config.version,\r\n          expected: 'SemVer format (e.g., 1.0.0 or 1.0.0-alpha.1)',\r\n          suggestion:\r\n            'Use SemVer format: MAJOR.MINOR.PATCH (e.g., \"1.0.0\")',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  if (!config.project) {\r\n    issues.push(\r\n      createIssue(\r\n        'REQUIRED_FIELD',\r\n        'Missing required field: project',\r\n        'error',\r\n        {\r\n          filePath,\r\n          suggestion: 'Add a project section with at least a name field',\r\n        }\r\n      )\r\n    );\r\n  } else if (!config.project.name) {\r\n    issues.push(\r\n      createIssue(\r\n        'REQUIRED_FIELD',\r\n        'Missing required field: project.name',\r\n        'error',\r\n        {\r\n          filePath,\r\n          suggestion: 'Add a name field to the project section',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  // Validate project version if present\r\n  if (\r\n    config.project?.version &&\r\n    !/^\\d+\\.\\d+\\.\\d+(-[\\w.]+)?$/.test(config.project.version)\r\n  ) {\r\n    issues.push(\r\n      createIssue(\r\n        'INVALID_VERSION',\r\n        `Invalid project version format: ${config.project.version}`,\r\n        'error',\r\n        {\r\n          filePath,\r\n          value: config.project.version,\r\n          expected: 'SemVer format (e.g., 1.0.0)',\r\n          suggestion: 'Use SemVer format: MAJOR.MINOR.PATCH',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Validate that directories referenced in the config exist\r\n */\r\nasync function validateDirectoryReferences(\r\n  config: PkfConfigSchema,\r\n  rootDir: string,\r\n  configPath: string,\r\n  checkOptional: boolean\r\n): Promise<ValidationIssue[]> {\r\n  const issues: ValidationIssue[] = [];\r\n  const structure = config.structure ?? {};\r\n\r\n  // Define which directories to check\r\n  const directoriesToCheck: Array<{\r\n    key: string;\r\n    path: string;\r\n    required: boolean;\r\n    description: string;\r\n  }> = [];\r\n\r\n  // docsDir is typically required\r\n  const docsDir: string = structure.docsDir ?? STRUCTURE_DIRECTORIES.docsDir;\r\n  directoriesToCheck.push({\r\n    key: 'docsDir',\r\n    path: docsDir,\r\n    required: true,\r\n    description: 'main documentation directory',\r\n  });\r\n\r\n  // registersDir is important for PKF functionality\r\n  const registersDir: string =\r\n    structure.registersDir ?? STRUCTURE_DIRECTORIES.registersDir;\r\n  directoriesToCheck.push({\r\n    key: 'registersDir',\r\n    path: registersDir,\r\n    required: true,\r\n    description: 'registers directory (TODO, ISSUES, CHANGELOG)',\r\n  });\r\n\r\n  // Optional directories - only check if explicitly configured or checkOptional is true\r\n  if (structure.templatesDir || checkOptional) {\r\n    const templatesPath: string = structure.templatesDir ?? STRUCTURE_DIRECTORIES.templatesDir;\r\n    directoriesToCheck.push({\r\n      key: 'templatesDir',\r\n      path: templatesPath,\r\n      required: false,\r\n      description: 'templates directory',\r\n    });\r\n  }\r\n\r\n  if (structure.schemasDir || checkOptional) {\r\n    const schemasPath: string = structure.schemasDir ?? STRUCTURE_DIRECTORIES.schemasDir;\r\n    directoriesToCheck.push({\r\n      key: 'schemasDir',\r\n      path: schemasPath,\r\n      required: false,\r\n      description: 'schemas directory',\r\n    });\r\n  }\r\n\r\n  if (structure.agentsDir || checkOptional) {\r\n    const agentsPath: string = structure.agentsDir ?? STRUCTURE_DIRECTORIES.agentsDir;\r\n    directoriesToCheck.push({\r\n      key: 'agentsDir',\r\n      path: agentsPath,\r\n      required: false,\r\n      description: 'AI agents directory',\r\n    });\r\n  }\r\n\r\n  if (structure.archiveDir) {\r\n    directoriesToCheck.push({\r\n      key: 'archiveDir',\r\n      path: structure.archiveDir,\r\n      required: false,\r\n      description: 'documentation archive directory',\r\n    });\r\n  }\r\n\r\n  // Check packages directory if enabled\r\n  if (config.packages?.enabled) {\r\n    const packagesDir: string = config.packages.directory ?? 'packages';\r\n    directoriesToCheck.push({\r\n      key: 'packages.directory',\r\n      path: packagesDir,\r\n      required: true,\r\n      description: 'packages directory (multi-package mode enabled)',\r\n    });\r\n  }\r\n\r\n  // Validate each directory\r\n  for (const dir of directoriesToCheck) {\r\n    const fullPath = join(rootDir, dir.path);\r\n    const exists = await isDirectory(fullPath);\r\n\r\n    if (!exists) {\r\n      if (dir.required) {\r\n        issues.push(\r\n          createIssue(\r\n            'DIRECTORY_NOT_FOUND',\r\n            `Required directory not found: ${dir.path} (${dir.description})`,\r\n            'error',\r\n            {\r\n              filePath: configPath,\r\n              value: dir.path,\r\n              suggestion: `Create the directory: mkdir -p ${dir.path}`,\r\n            }\r\n          )\r\n        );\r\n      } else {\r\n        issues.push(\r\n          createIssue(\r\n            'DIRECTORY_MISSING',\r\n            `Configured directory not found: ${dir.path} (${dir.description})`,\r\n            'warning',\r\n            {\r\n              filePath: configPath,\r\n              value: dir.path,\r\n              suggestion: `Create the directory or remove the '${dir.key}' configuration`,\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check register files if registersDir exists\r\n  const fullRegistersDir = join(rootDir, registersDir);\r\n  if (await isDirectory(fullRegistersDir)) {\r\n    const registerFiles = await validateRegisterFiles(\r\n      config,\r\n      rootDir,\r\n      registersDir,\r\n      configPath\r\n    );\r\n    issues.push(...registerFiles);\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Validate that register files exist\r\n */\r\nasync function validateRegisterFiles(\r\n  config: PkfConfigSchema,\r\n  rootDir: string,\r\n  registersDir: string,\r\n  configPath: string\r\n): Promise<ValidationIssue[]> {\r\n  const issues: ValidationIssue[] = [];\r\n  const registers = config.registers ?? {};\r\n\r\n  const registerFilesToCheck = [\r\n    {\r\n      key: 'todoFile',\r\n      file: registers.todoFile ?? 'TODO.md',\r\n      description: 'TODO register',\r\n    },\r\n    {\r\n      key: 'issuesFile',\r\n      file: registers.issuesFile ?? 'ISSUES.md',\r\n      description: 'Issues register',\r\n    },\r\n    {\r\n      key: 'changelogFile',\r\n      file: registers.changelogFile ?? 'CHANGELOG.md',\r\n      description: 'Changelog register',\r\n    },\r\n  ];\r\n\r\n  for (const register of registerFilesToCheck) {\r\n    const fullPath = join(rootDir, registersDir, register.file);\r\n    const exists = await fileExists(fullPath);\r\n\r\n    if (!exists) {\r\n      issues.push(\r\n        createIssue(\r\n          'REGISTER_FILE_MISSING',\r\n          `Register file not found: ${register.file} (${register.description})`,\r\n          'warning',\r\n          {\r\n            filePath: configPath,\r\n            value: join(registersDir, register.file),\r\n            suggestion: `Create the register file from template or run: touch ${join(registersDir, register.file)}`,\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Validate proposal range configurations\r\n */\r\nfunction validateProposalRanges(\r\n  ranges: NonNullable<PkfConfigSchema['proposals']>['ranges'],\r\n  configPath: string\r\n): ValidationIssue[] {\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  if (!ranges) return issues;\r\n\r\n  // Check for overlapping ranges\r\n  const rangeEntries = Object.entries(ranges);\r\n\r\n  for (let i = 0; i < rangeEntries.length; i++) {\r\n    const entry = rangeEntries[i];\r\n    if (!entry) continue;\r\n    const [name1, range1] = entry;\r\n\r\n    // Validate individual range\r\n    if (range1.min >= range1.max) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_RANGE',\r\n          `Proposal range '${name1}' has min >= max (${range1.min} >= ${range1.max})`,\r\n          'error',\r\n          {\r\n            filePath: configPath,\r\n            value: range1,\r\n            suggestion: 'Ensure min is less than max',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    if (range1.min < 0) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_RANGE',\r\n          `Proposal range '${name1}' has negative min value: ${range1.min}`,\r\n          'error',\r\n          {\r\n            filePath: configPath,\r\n            value: range1.min,\r\n            suggestion: 'Use a non-negative minimum value',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    // Check for overlaps with other ranges\r\n    for (let j = i + 1; j < rangeEntries.length; j++) {\r\n      const entry2 = rangeEntries[j];\r\n      if (!entry2) continue;\r\n      const [name2, range2] = entry2;\r\n\r\n      const overlaps =\r\n        (range1.min >= range2.min && range1.min <= range2.max) ||\r\n        (range1.max >= range2.min && range1.max <= range2.max) ||\r\n        (range2.min >= range1.min && range2.min <= range1.max);\r\n\r\n      if (overlaps) {\r\n        issues.push(\r\n          createIssue(\r\n            'OVERLAPPING_RANGES',\r\n            `Proposal ranges '${name1}' (${range1.min}-${range1.max}) and '${name2}' (${range2.min}-${range2.max}) overlap`,\r\n            'error',\r\n            {\r\n              filePath: configPath,\r\n              suggestion:\r\n                'Adjust ranges so they do not overlap',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Validate register ID configuration\r\n */\r\nfunction validateRegisterConfig(\r\n  registers: NonNullable<PkfConfigSchema['registers']>,\r\n  configPath: string\r\n): ValidationIssue[] {\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  // Validate ID prefixes are valid identifiers\r\n  if (registers.idPrefix) {\r\n    const prefixPattern = /^[A-Z][A-Z0-9_-]*$/;\r\n\r\n    for (const [key, prefix] of Object.entries(registers.idPrefix)) {\r\n      if (prefix && !prefixPattern.test(prefix)) {\r\n        issues.push(\r\n          createIssue(\r\n            'INVALID_ID_PREFIX',\r\n            `Invalid ID prefix for '${key}': ${prefix}`,\r\n            'warning',\r\n            {\r\n              filePath: configPath,\r\n              value: prefix,\r\n              expected: 'Uppercase letters, numbers, underscores, or hyphens',\r\n              suggestion:\r\n                'Use uppercase letters starting with a letter (e.g., \"TODO\", \"ISSUE-1\")',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for duplicate prefixes\r\n  if (registers.idPrefix) {\r\n    const prefixes = Object.entries(registers.idPrefix).filter(\r\n      ([_, v]) => v !== undefined\r\n    );\r\n    const prefixValues = prefixes.map(([_, v]) => v);\r\n    const duplicates = prefixValues.filter(\r\n      (v, i) => prefixValues.indexOf(v) !== i\r\n    );\r\n\r\n    if (duplicates.length > 0) {\r\n      const uniqueDuplicates = Array.from(new Set(duplicates));\r\n      issues.push(\r\n        createIssue(\r\n          'DUPLICATE_ID_PREFIX',\r\n          `Duplicate ID prefixes found: ${uniqueDuplicates.join(', ')}`,\r\n          'error',\r\n          {\r\n            filePath: configPath,\r\n            suggestion: 'Each register type should have a unique ID prefix',\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Categorize issues into the result object\r\n */\r\nfunction categorizeIssues(\r\n  issues: ValidationIssue[],\r\n  result: ValidationResult\r\n): void {\r\n  for (const issue of issues) {\r\n    switch (issue.severity) {\r\n      case 'error':\r\n        result.errors.push(issue);\r\n        break;\r\n      case 'warning':\r\n        result.warnings.push(issue);\r\n        break;\r\n      case 'info':\r\n        result.info.push(issue);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Load and return the parsed PKF config\r\n *\r\n * @param options - Options for loading the config\r\n * @returns The parsed config or null if invalid\r\n */\r\nexport async function loadConfig(\r\n  options: ConfigValidationOptions = {}\r\n): Promise<{ config: PkfConfigSchema | null; result: ValidationResult }> {\r\n  const result = await validateConfig(options);\r\n\r\n  if (!result.valid) {\r\n    return { config: null, result };\r\n  }\r\n\r\n  const rootDir = options.rootDir ?? process.cwd();\r\n  const configPath = options.configPath ?? getConfigPath(rootDir);\r\n\r\n  try {\r\n    const config = await readYamlFile<PkfConfigSchema>(configPath);\r\n    return { config, result };\r\n  } catch {\r\n    return { config: null, result };\r\n  }\r\n}\r\n\r\nexport default validateConfig;\r\n","/**\r\n * File utility functions for validators\r\n */\r\n\r\nimport { readFile, access, stat } from 'fs/promises';\r\nimport { join, resolve } from 'path';\r\nimport { constants } from 'fs';\r\nimport matter from 'gray-matter';\r\n\r\n/**\r\n * Check if a file exists and is readable\r\n */\r\nexport async function fileExists(filePath: string): Promise<boolean> {\r\n  try {\r\n    await access(filePath, constants.R_OK);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a path is a directory\r\n */\r\nexport async function isDirectory(path: string): Promise<boolean> {\r\n  try {\r\n    const stats = await stat(path);\r\n    return stats.isDirectory();\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Read a file as text\r\n */\r\nexport async function readTextFile(filePath: string): Promise<string> {\r\n  return readFile(filePath, 'utf-8');\r\n}\r\n\r\n/**\r\n * Read and parse a YAML file\r\n */\r\nexport async function readYamlFile<T = unknown>(filePath: string): Promise<T> {\r\n  const { parse } = await import('yaml');\r\n  const content = await readTextFile(filePath);\r\n  return parse(content) as T;\r\n}\r\n\r\n/**\r\n * Read and parse a JSON file\r\n */\r\nexport async function readJsonFile<T = unknown>(filePath: string): Promise<T> {\r\n  const content = await readTextFile(filePath);\r\n  return JSON.parse(content) as T;\r\n}\r\n\r\n/**\r\n * Parse frontmatter from markdown content\r\n */\r\nexport function parseFrontmatter(content: string): {\r\n  data: Record<string, unknown>;\r\n  content: string;\r\n} {\r\n  const parsed = matter(content);\r\n  return {\r\n    data: parsed.data as Record<string, unknown>,\r\n    content: parsed.content,\r\n  };\r\n}\r\n\r\n/**\r\n * Read markdown file and extract frontmatter\r\n */\r\nexport async function readMarkdownWithFrontmatter(filePath: string): Promise<{\r\n  frontmatter: Record<string, unknown>;\r\n  content: string;\r\n  raw: string;\r\n}> {\r\n  const raw = await readTextFile(filePath);\r\n  const { data, content } = parseFrontmatter(raw);\r\n  return {\r\n    frontmatter: data,\r\n    content,\r\n    raw,\r\n  };\r\n}\r\n\r\n/**\r\n * Resolve a path relative to a root directory\r\n */\r\nexport function resolvePath(rootDir: string, relativePath: string): string {\r\n  return resolve(rootDir, relativePath);\r\n}\r\n\r\n/**\r\n * Get the default PKF config path\r\n */\r\nexport function getConfigPath(rootDir: string = process.cwd()): string {\r\n  return join(rootDir, 'pkf.config.yaml');\r\n}\r\n\r\n/**\r\n * Get the default docs directory path\r\n */\r\nexport function getDocsPath(rootDir: string = process.cwd()): string {\r\n  return join(rootDir, 'docs');\r\n}\r\n\r\n/**\r\n * Get the registers directory path\r\n */\r\nexport function getRegistersPath(rootDir: string = process.cwd()): string {\r\n  return join(rootDir, 'docs', 'registers');\r\n}\r\n","/**\r\n * Schema validation utilities using AJV\r\n */\r\n\r\nimport Ajv, { type ErrorObject, type ValidateFunction } from 'ajv';\r\nimport { createIssue, type ValidationIssue } from '../types/index.js';\r\n\r\n// Singleton AJV instance\r\nlet ajvInstance: Ajv | null = null;\r\n\r\n/**\r\n * Get or create the AJV instance\r\n */\r\nexport function getAjv(): Ajv {\r\n  if (!ajvInstance) {\r\n    ajvInstance = new Ajv({\r\n      allErrors: true,\r\n      verbose: true,\r\n      strict: false,\r\n      validateFormats: true,\r\n    });\r\n\r\n    // Add common formats\r\n    ajvInstance.addFormat('date', {\r\n      type: 'string',\r\n      validate: (str: string) => /^\\d{4}-\\d{2}-\\d{2}$/.test(str),\r\n    });\r\n\r\n    ajvInstance.addFormat('datetime', {\r\n      type: 'string',\r\n      validate: (str: string) => !isNaN(Date.parse(str)),\r\n    });\r\n\r\n    ajvInstance.addFormat('semver', {\r\n      type: 'string',\r\n      validate: (str: string) => /^\\d+\\.\\d+\\.\\d+(-[\\w.]+)?(\\+[\\w.]+)?$/.test(str),\r\n    });\r\n\r\n    // Add URI format\r\n    ajvInstance.addFormat('uri', {\r\n      type: 'string',\r\n      validate: (str: string) => {\r\n        try {\r\n          new URL(str);\r\n          return true;\r\n        } catch {\r\n          return false;\r\n        }\r\n      },\r\n    });\r\n\r\n    // Add email format\r\n    ajvInstance.addFormat('email', {\r\n      type: 'string',\r\n      validate: (str: string) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(str),\r\n    });\r\n  }\r\n  return ajvInstance;\r\n}\r\n\r\n// Cache for compiled schemas by their $id\r\nconst schemaCache = new Map<string, ValidateFunction<unknown>>();\r\n\r\n/**\r\n * Compile a JSON schema for validation.\r\n * Caches compiled schemas by their $id to avoid re-compilation errors.\r\n */\r\nexport function compileSchema<T = unknown>(schema: object): ValidateFunction<T> {\r\n  const ajv = getAjv();\r\n  const schemaObj = schema as { $id?: string };\r\n  const schemaId = schemaObj.$id;\r\n\r\n  // Check cache first if schema has an $id\r\n  if (schemaId && schemaCache.has(schemaId)) {\r\n    return schemaCache.get(schemaId) as ValidateFunction<T>;\r\n  }\r\n\r\n  // Check if already added to AJV\r\n  if (schemaId) {\r\n    const existing = ajv.getSchema(schemaId);\r\n    if (existing) {\r\n      schemaCache.set(schemaId, existing as ValidateFunction<unknown>);\r\n      return existing as ValidateFunction<T>;\r\n    }\r\n  }\r\n\r\n  const compiled = ajv.compile<T>(schema);\r\n\r\n  // Cache the compiled schema\r\n  if (schemaId) {\r\n    schemaCache.set(schemaId, compiled as ValidateFunction<unknown>);\r\n  }\r\n\r\n  return compiled;\r\n}\r\n\r\n/**\r\n * Convert AJV errors to ValidationIssues\r\n */\r\nexport function ajvErrorsToIssues(\r\n  errors: ErrorObject[] | null | undefined,\r\n  filePath?: string\r\n): ValidationIssue[] {\r\n  if (!errors || errors.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  return errors.map((error) => {\r\n    const path = error.instancePath || '/';\r\n    const keyword = error.keyword;\r\n\r\n    let code: string;\r\n    let message: string;\r\n    let suggestion: string | undefined;\r\n\r\n    switch (keyword) {\r\n      case 'required':\r\n        code = 'REQUIRED_FIELD';\r\n        message = `Missing required field: ${error.params.missingProperty} at ${path}`;\r\n        suggestion = `Add the '${error.params.missingProperty}' field`;\r\n        break;\r\n      case 'type':\r\n        code = 'INVALID_TYPE';\r\n        message = `Invalid type at ${path}: expected ${error.params.type}, got ${typeof error.data}`;\r\n        suggestion = `Change the value to type '${error.params.type}'`;\r\n        break;\r\n      case 'enum':\r\n        code = 'INVALID_ENUM';\r\n        message = `Invalid value at ${path}: must be one of ${JSON.stringify(error.params.allowedValues)}`;\r\n        suggestion = `Use one of: ${error.params.allowedValues.join(', ')}`;\r\n        break;\r\n      case 'pattern':\r\n        code = 'PATTERN_MISMATCH';\r\n        message = `Value at ${path} does not match pattern: ${error.params.pattern}`;\r\n        suggestion = `Ensure the value matches the pattern: ${error.params.pattern}`;\r\n        break;\r\n      case 'format':\r\n        code = 'INVALID_FORMAT';\r\n        message = `Invalid format at ${path}: expected ${error.params.format}`;\r\n        suggestion = `Use the correct format: ${error.params.format}`;\r\n        break;\r\n      case 'additionalProperties':\r\n        code = 'ADDITIONAL_PROPERTY';\r\n        message = `Unknown property '${error.params.additionalProperty}' at ${path}`;\r\n        suggestion = `Remove the property '${error.params.additionalProperty}' or check spelling`;\r\n        break;\r\n      case 'minimum':\r\n      case 'maximum':\r\n      case 'minLength':\r\n      case 'maxLength':\r\n        code = 'OUT_OF_RANGE';\r\n        message = `Value at ${path} ${error.message}`;\r\n        break;\r\n      default:\r\n        code = `SCHEMA_${keyword.toUpperCase()}`;\r\n        message = `Schema validation failed at ${path}: ${error.message}`;\r\n    }\r\n\r\n    return createIssue(code, message, 'error', {\r\n      filePath,\r\n      value: error.data,\r\n      expected: error.params,\r\n      suggestion,\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Validate data against a schema and return validation issues\r\n */\r\nexport function validateWithSchema<T = unknown>(\r\n  data: unknown,\r\n  schema: object,\r\n  filePath?: string\r\n): { valid: boolean; data?: T; issues: ValidationIssue[] } {\r\n  const validate = compileSchema<T>(schema);\r\n  const valid = validate(data);\r\n\r\n  if (valid) {\r\n    return { valid: true, data: data as T, issues: [] };\r\n  }\r\n\r\n  return {\r\n    valid: false,\r\n    issues: ajvErrorsToIssues(validate.errors, filePath),\r\n  };\r\n}\r\n","/**\r\n * PKF TODO Register Validator\r\n *\r\n * Validates TODO.md files against the PKF TODO item schema.\r\n * Parses TODO items from markdown, validates frontmatter against schema,\r\n * and checks for ID uniqueness and valid date formats.\r\n */\r\n\r\nimport { parse as parseYaml } from 'yaml';\r\nimport {\r\n  createEmptyResult,\r\n  createIssue,\r\n  type ValidationResult,\r\n  type ValidationOptions,\r\n} from '../types/index.js';\r\nimport { fileExists, readTextFile, readJsonFile } from '../utils/index.js';\r\nimport { validateWithSchema } from '../utils/schema-utils.js';\r\nimport { resolve, dirname } from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\n/**\r\n * Represents a parsed TODO item from the markdown file\r\n */\r\ninterface ParsedTodoItem {\r\n  /** The raw YAML content of the frontmatter */\r\n  rawYaml: string;\r\n  /** Parsed frontmatter data */\r\n  data: Record<string, unknown>;\r\n  /** Line number where the item starts */\r\n  startLine: number;\r\n  /** Line number where the YAML block starts */\r\n  yamlStartLine: number;\r\n  /** The TODO header text */\r\n  headerText: string;\r\n}\r\n\r\n/**\r\n * Get the default TODO schema path\r\n */\r\nfunction getDefaultSchemaPath(): string {\r\n  // Try to resolve relative to this module\r\n  const currentDir = dirname(fileURLToPath(import.meta.url));\r\n  // Go up from src/validators to package root, then to repo root, then to schemas\r\n  return resolve(currentDir, '..', '..', '..', '..', 'schemas', 'todo-item.schema.json');\r\n}\r\n\r\n/**\r\n * Parse TODO items from markdown content\r\n *\r\n * Looks for patterns like:\r\n * ### TODO-XXX: Title\r\n * ```yaml\r\n * frontmatter...\r\n * ```\r\n */\r\nfunction parseTodoItems(content: string, filePath: string): ParsedTodoItem[] {\r\n  const items: ParsedTodoItem[] = [];\r\n  // Normalize line endings and split\r\n  const normalizedContent = content.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\r\n  const lines = normalizedContent.split('\\n');\r\n\r\n  // Pattern to match TODO headers (### TODO-XXX: Title)\r\n  const headerPattern = /^###\\s+(TODO-\\d{3,})(?::\\s*(.*))?$/;\r\n  // Pattern to match code block start with yaml\r\n  const yamlBlockStart = /^```ya?ml\\s*$/;\r\n  const yamlBlockEnd = /^```\\s*$/;\r\n\r\n  let i = 0;\r\n  while (i < lines.length) {\r\n    const line = lines[i];\r\n    if (line === undefined) {\r\n      i++;\r\n      continue;\r\n    }\r\n    const headerMatch = line.match(headerPattern);\r\n\r\n    if (headerMatch) {\r\n      const todoId = headerMatch[1];\r\n      const title = headerMatch[2] || '';\r\n      const headerLine = i + 1; // 1-based line number\r\n\r\n      // Look for YAML block after the header\r\n      let j = i + 1;\r\n\r\n      // Skip empty lines\r\n      while (j < lines.length && (lines[j]?.trim() ?? '') === '') {\r\n        j++;\r\n      }\r\n\r\n      // Check if we found a YAML block\r\n      const currentLine = lines[j];\r\n      if (j < lines.length && currentLine !== undefined && yamlBlockStart.test(currentLine)) {\r\n        const yamlStartLine = j + 1; // 1-based line number\r\n        j++; // Move past the ```yaml line\r\n\r\n        // Collect YAML content until closing ```\r\n        const yamlLines: string[] = [];\r\n        while (j < lines.length) {\r\n          const yamlLine = lines[j];\r\n          if (yamlLine === undefined || yamlBlockEnd.test(yamlLine)) {\r\n            break;\r\n          }\r\n          yamlLines.push(yamlLine);\r\n          j++;\r\n        }\r\n\r\n        const rawYaml = yamlLines.join('\\n');\r\n\r\n        // Parse the YAML\r\n        try {\r\n          const data = parseYaml(rawYaml) as Record<string, unknown>;\r\n          items.push({\r\n            rawYaml,\r\n            data: data || {},\r\n            startLine: headerLine,\r\n            yamlStartLine,\r\n            headerText: `${todoId}${title ? ': ' + title : ''}`,\r\n          });\r\n        } catch (error) {\r\n          // We'll add a parsing error but still track the item location\r\n          items.push({\r\n            rawYaml,\r\n            data: { _parseError: error instanceof Error ? error.message : String(error) },\r\n            startLine: headerLine,\r\n            yamlStartLine,\r\n            headerText: `${todoId}${title ? ': ' + title : ''}`,\r\n          });\r\n        }\r\n\r\n        i = j + 1; // Move past the closing ```\r\n        continue;\r\n      }\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  return items;\r\n}\r\n\r\n/**\r\n * Validate date string format (YYYY-MM-DD) and check if it's a valid date\r\n */\r\nfunction isValidDate(dateStr: string): boolean {\r\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr)) {\r\n    return false;\r\n  }\r\n\r\n  const parts = dateStr.split('-').map(Number);\r\n  const year = parts[0];\r\n  const month = parts[1];\r\n  const day = parts[2];\r\n\r\n  if (year === undefined || month === undefined || day === undefined) {\r\n    return false;\r\n  }\r\n\r\n  const date = new Date(year, month - 1, day);\r\n\r\n  return (\r\n    date.getFullYear() === year &&\r\n    date.getMonth() === month - 1 &&\r\n    date.getDate() === day\r\n  );\r\n}\r\n\r\n/**\r\n * Options for TODO validation\r\n */\r\nexport interface TodoValidationOptions extends ValidationOptions {\r\n  /** Path to the TODO item schema. If not provided, uses default. */\r\n  schemaPath?: string;\r\n  /** Whether to validate date values are semantically valid */\r\n  validateDates?: boolean;\r\n  /** Whether to check for orphaned dependencies (references to non-existent TODOs) */\r\n  checkDependencies?: boolean;\r\n}\r\n\r\n/**\r\n * Validate a TODO.md file\r\n *\r\n * @param todoPath - Path to the TODO.md file\r\n * @param options - Validation options\r\n * @returns Validation result with errors, warnings, and info messages\r\n */\r\nexport async function validateTodo(\r\n  todoPath: string,\r\n  options: TodoValidationOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n\r\n  const {\r\n    schemaPath = getDefaultSchemaPath(),\r\n    validateDates = true,\r\n    checkDependencies = true,\r\n    includeWarnings = true,\r\n    includeInfo = true,\r\n    maxErrors,\r\n  } = options;\r\n\r\n  // Check if file exists\r\n  if (!(await fileExists(todoPath))) {\r\n    result.errors.push(\r\n      createIssue('FILE_NOT_FOUND', `TODO file not found: ${todoPath}`, 'error', {\r\n        filePath: todoPath,\r\n      })\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Load schema\r\n  let schema: Record<string, unknown>;\r\n  try {\r\n    if (!(await fileExists(schemaPath))) {\r\n      result.errors.push(\r\n        createIssue('SCHEMA_NOT_FOUND', `TODO schema not found: ${schemaPath}`, 'error', {\r\n          filePath: schemaPath,\r\n          suggestion: 'Ensure todo-item.schema.json exists in the schemas directory',\r\n        })\r\n      );\r\n      result.valid = false;\r\n      result.duration = Date.now() - startTime;\r\n      return result;\r\n    }\r\n    schema = await readJsonFile<Record<string, unknown>>(schemaPath);\r\n  } catch (error) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'SCHEMA_LOAD_ERROR',\r\n        `Failed to load TODO schema: ${error instanceof Error ? error.message : String(error)}`,\r\n        'error',\r\n        { filePath: schemaPath }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Read and parse TODO file\r\n  let content: string;\r\n  try {\r\n    content = await readTextFile(todoPath);\r\n  } catch (error) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'FILE_READ_ERROR',\r\n        `Failed to read TODO file: ${error instanceof Error ? error.message : String(error)}`,\r\n        'error',\r\n        { filePath: todoPath }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Parse TODO items\r\n  const items = parseTodoItems(content, todoPath);\r\n\r\n  if (items.length === 0) {\r\n    if (includeInfo) {\r\n      result.info.push(\r\n        createIssue('NO_TODO_ITEMS', 'No TODO items found in the file', 'info', {\r\n          filePath: todoPath,\r\n        })\r\n      );\r\n    }\r\n    result.duration = Date.now() - startTime;\r\n    result.itemCount = 0;\r\n    return result;\r\n  }\r\n\r\n  // Track IDs for uniqueness check\r\n  const seenIds = new Map<string, number>(); // id -> first occurrence line number\r\n  const allIds = new Set<string>();\r\n\r\n  // Validate each item\r\n  for (const item of items) {\r\n    // Check for early termination on maxErrors\r\n    if (maxErrors !== undefined && result.errors.length >= maxErrors) {\r\n      if (includeWarnings) {\r\n        result.warnings.push(\r\n          createIssue(\r\n            'MAX_ERRORS_REACHED',\r\n            `Maximum error count (${maxErrors}) reached, stopping validation`,\r\n            'warning',\r\n            { filePath: todoPath }\r\n          )\r\n        );\r\n      }\r\n      break;\r\n    }\r\n\r\n    // Check for YAML parsing errors\r\n    if (item.data._parseError) {\r\n      result.errors.push(\r\n        createIssue(\r\n          'YAML_PARSE_ERROR',\r\n          `Failed to parse YAML for ${item.headerText}: ${item.data._parseError}`,\r\n          'error',\r\n          {\r\n            filePath: todoPath,\r\n            line: item.yamlStartLine,\r\n          }\r\n        )\r\n      );\r\n      continue;\r\n    }\r\n\r\n    const itemId = item.data.id as string | undefined;\r\n\r\n    // Check ID uniqueness\r\n    if (itemId) {\r\n      allIds.add(itemId);\r\n\r\n      if (seenIds.has(itemId)) {\r\n        result.errors.push(\r\n          createIssue(\r\n            'DUPLICATE_ID',\r\n            `Duplicate TODO ID: ${itemId} (first seen at line ${seenIds.get(itemId)})`,\r\n            'error',\r\n            {\r\n              filePath: todoPath,\r\n              line: item.startLine,\r\n              value: itemId,\r\n              suggestion: `Use a unique ID for this TODO item`,\r\n            }\r\n          )\r\n        );\r\n      } else {\r\n        seenIds.set(itemId, item.startLine);\r\n      }\r\n    }\r\n\r\n    // Validate against schema\r\n    const schemaResult = validateWithSchema(item.data, schema, todoPath);\r\n\r\n    if (!schemaResult.valid) {\r\n      // Add line information to schema errors\r\n      for (const issue of schemaResult.issues) {\r\n        result.errors.push({\r\n          ...issue,\r\n          line: item.yamlStartLine,\r\n          message: `[${itemId || item.headerText}] ${issue.message}`,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Additional date validation\r\n    if (validateDates) {\r\n      const dateFields = ['created', 'updated', 'due_date'] as const;\r\n\r\n      for (const field of dateFields) {\r\n        const value = item.data[field];\r\n        if (typeof value === 'string') {\r\n          if (!isValidDate(value)) {\r\n            result.errors.push(\r\n              createIssue(\r\n                'INVALID_DATE',\r\n                `[${itemId || item.headerText}] Invalid date value for '${field}': ${value}`,\r\n                'error',\r\n                {\r\n                  filePath: todoPath,\r\n                  line: item.yamlStartLine,\r\n                  value,\r\n                  expected: 'YYYY-MM-DD format with valid date',\r\n                  suggestion: `Use a valid date in YYYY-MM-DD format (e.g., 2025-01-15)`,\r\n                }\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check date logic: updated should be >= created\r\n      const created = item.data.created as string | undefined;\r\n      const updated = item.data.updated as string | undefined;\r\n\r\n      if (created && updated && isValidDate(created) && isValidDate(updated)) {\r\n        if (updated < created) {\r\n          if (includeWarnings) {\r\n            result.warnings.push(\r\n              createIssue(\r\n                'DATE_LOGIC_ERROR',\r\n                `[${itemId || item.headerText}] 'updated' date (${updated}) is before 'created' date (${created})`,\r\n                'warning',\r\n                {\r\n                  filePath: todoPath,\r\n                  line: item.yamlStartLine,\r\n                  value: { created, updated },\r\n                  suggestion: `Update the 'updated' date to be on or after the 'created' date`,\r\n                }\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for orphaned dependencies\r\n  if (checkDependencies) {\r\n    for (const item of items) {\r\n      if (item.data._parseError) continue;\r\n\r\n      const itemId = item.data.id as string;\r\n      const dependsOn = item.data.depends_on as string[] | undefined;\r\n      const blocks = item.data.blocks as string[] | undefined;\r\n\r\n      // Check depends_on references\r\n      if (Array.isArray(dependsOn)) {\r\n        for (const depId of dependsOn) {\r\n          if (!allIds.has(depId)) {\r\n            if (includeWarnings) {\r\n              result.warnings.push(\r\n                createIssue(\r\n                  'ORPHANED_DEPENDENCY',\r\n                  `[${itemId}] References non-existent TODO in 'depends_on': ${depId}`,\r\n                  'warning',\r\n                  {\r\n                    filePath: todoPath,\r\n                    line: item.yamlStartLine,\r\n                    value: depId,\r\n                    suggestion: `Remove the reference or ensure ${depId} exists`,\r\n                  }\r\n                )\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Check blocks references\r\n      if (Array.isArray(blocks)) {\r\n        for (const blockId of blocks) {\r\n          if (!allIds.has(blockId)) {\r\n            if (includeWarnings) {\r\n              result.warnings.push(\r\n                createIssue(\r\n                  'ORPHANED_DEPENDENCY',\r\n                  `[${itemId}] References non-existent TODO in 'blocks': ${blockId}`,\r\n                  'warning',\r\n                  {\r\n                    filePath: todoPath,\r\n                    line: item.yamlStartLine,\r\n                    value: blockId,\r\n                    suggestion: `Remove the reference or ensure ${blockId} exists`,\r\n                  }\r\n                )\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Set final result properties\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n  result.itemCount = items.length;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Default export for convenience\r\n */\r\nexport default validateTodo;\r\n","/**\r\n * PKF Issue Validator\r\n *\r\n * Validates ISSUES.md register files against the PKF issue-item schema.\r\n * Parses issue items, validates frontmatter, checks ID uniqueness, and validates\r\n * status/severity values.\r\n */\r\n\r\nimport { resolve, dirname } from 'path';\r\nimport { fileURLToPath } from 'url';\r\nimport { parse as parseYaml } from 'yaml';\r\nimport {\r\n  type ValidationResult,\r\n  type ValidationIssue,\r\n  type ValidationOptions,\r\n  createEmptyResult,\r\n  createIssue,\r\n} from '../types/index.js';\r\nimport { fileExists, readTextFile, readJsonFile } from '../utils/index.js';\r\nimport { validateWithSchema } from '../utils/schema-utils.js';\r\n\r\n/**\r\n * Parsed issue item from ISSUES.md\r\n */\r\nexport interface ParsedIssueItem {\r\n  /** The issue ID (e.g., ISSUE-001) */\r\n  id: string;\r\n  /** The issue title from the heading */\r\n  title: string;\r\n  /** Line number where the issue starts */\r\n  lineNumber: number;\r\n  /** The parsed frontmatter/YAML data */\r\n  frontmatter: Record<string, unknown>;\r\n  /** Raw YAML content */\r\n  rawYaml: string;\r\n}\r\n\r\n/**\r\n * Valid issue status values\r\n */\r\nconst VALID_STATUSES = ['open', 'investigating', 'in-progress', 'resolved', 'wontfix', 'duplicate'] as const;\r\n\r\n/**\r\n * Valid severity values\r\n */\r\nconst VALID_SEVERITIES = ['critical', 'high', 'medium', 'low'] as const;\r\n\r\n/**\r\n * Issue ID pattern\r\n */\r\nconst ISSUE_ID_PATTERN = /^ISSUE-\\d{3,}$/;\r\n\r\n/**\r\n * Pattern to match issue headings (### ISSUE-XXX: Title)\r\n */\r\nconst ISSUE_HEADING_PATTERN = /^###\\s+(ISSUE-\\d{3,})(?::\\s*(.*))?$/;\r\n\r\n/**\r\n * Default schema path (relative to module location)\r\n */\r\nfunction getDefaultSchemaPath(): string {\r\n  // Resolve relative to this module\r\n  const currentDir = dirname(fileURLToPath(import.meta.url));\r\n  // Go up from src/validators to package root, then to repo root, then to schemas\r\n  return resolve(currentDir, '..', '..', '..', '..', 'schemas', 'issue-item.schema.json');\r\n}\r\n\r\n/**\r\n * Parse ISSUES.md content and extract individual issue items\r\n *\r\n * Looks for patterns like:\r\n * ### ISSUE-XXX: Title\r\n * ```yaml\r\n * frontmatter...\r\n * ```\r\n */\r\nfunction parseIssueItems(\r\n  content: string,\r\n  filePath: string\r\n): { issues: ParsedIssueItem[]; parseErrors: ValidationIssue[] } {\r\n  const issues: ParsedIssueItem[] = [];\r\n  const parseErrors: ValidationIssue[] = [];\r\n  const lines = content.split('\\n');\r\n\r\n  let currentIssue: Partial<ParsedIssueItem> | null = null;\r\n  let inYamlBlock = false;\r\n  let yamlContent: string[] = [];\r\n  let yamlStartLine = 0;\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i] ?? '';\r\n    const lineNumber = i + 1;\r\n\r\n    // Check for issue heading\r\n    const headingMatch = line.match(ISSUE_HEADING_PATTERN);\r\n    if (headingMatch) {\r\n      // Save previous issue if exists\r\n      if (currentIssue && currentIssue.id) {\r\n        issues.push(currentIssue as ParsedIssueItem);\r\n      }\r\n\r\n      const issueId = headingMatch[1] ?? '';\r\n      currentIssue = {\r\n        id: issueId,\r\n        title: headingMatch[2]?.trim() || '',\r\n        lineNumber,\r\n        frontmatter: {},\r\n        rawYaml: '',\r\n      };\r\n      continue;\r\n    }\r\n\r\n    // Track YAML blocks within an issue context\r\n    if (currentIssue) {\r\n      // Start of YAML block\r\n      if (/^```ya?ml\\s*$/.test(line)) {\r\n        inYamlBlock = true;\r\n        yamlContent = [];\r\n        yamlStartLine = lineNumber;\r\n        continue;\r\n      }\r\n\r\n      // End of YAML block\r\n      if (inYamlBlock && /^```\\s*$/.test(line)) {\r\n        inYamlBlock = false;\r\n        const rawYaml = yamlContent.join('\\n');\r\n        currentIssue.rawYaml = rawYaml;\r\n\r\n        // Parse YAML content\r\n        try {\r\n          currentIssue.frontmatter = (parseYaml(rawYaml) as Record<string, unknown>) || {};\r\n        } catch (error) {\r\n          const issueId = currentIssue.id ?? 'unknown';\r\n          parseErrors.push(\r\n            createIssue(\r\n              'YAML_PARSE_ERROR',\r\n              `Failed to parse YAML for ${issueId}: ${error instanceof Error ? error.message : String(error)}`,\r\n              'error',\r\n              {\r\n                filePath,\r\n                line: yamlStartLine,\r\n                value: rawYaml.substring(0, 100),\r\n                suggestion: 'Check YAML syntax for errors',\r\n              }\r\n            )\r\n          );\r\n          currentIssue.frontmatter = {};\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // Collect YAML content\r\n      if (inYamlBlock) {\r\n        yamlContent.push(line);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Don't forget the last issue\r\n  if (currentIssue && currentIssue.id) {\r\n    issues.push(currentIssue as ParsedIssueItem);\r\n  }\r\n\r\n  return { issues, parseErrors };\r\n}\r\n\r\n/**\r\n * Validate ID uniqueness across all issues\r\n */\r\nfunction validateIdUniqueness(\r\n  issues: ParsedIssueItem[],\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const errors: ValidationIssue[] = [];\r\n  const seenIds = new Map<string, number>();\r\n\r\n  for (const issue of issues) {\r\n    const existingLine = seenIds.get(issue.id);\r\n    if (existingLine !== undefined) {\r\n      errors.push(\r\n        createIssue(\r\n          'DUPLICATE_ID',\r\n          `Duplicate issue ID '${issue.id}' found (first occurrence at line ${existingLine})`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: issue.lineNumber,\r\n            value: issue.id,\r\n            suggestion: `Use a unique ID for this issue (e.g., increment the number)`,\r\n          }\r\n        )\r\n      );\r\n    } else {\r\n      seenIds.set(issue.id, issue.lineNumber);\r\n    }\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\n/**\r\n * Validate ID format\r\n */\r\nfunction validateIdFormat(\r\n  issue: ParsedIssueItem,\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const errors: ValidationIssue[] = [];\r\n\r\n  // Check heading ID format\r\n  if (!ISSUE_ID_PATTERN.test(issue.id)) {\r\n    errors.push(\r\n      createIssue(\r\n        'INVALID_ID_FORMAT',\r\n        `Invalid issue ID format '${issue.id}': must match pattern ISSUE-XXX (e.g., ISSUE-001)`,\r\n        'error',\r\n        {\r\n          filePath,\r\n          line: issue.lineNumber,\r\n          value: issue.id,\r\n          expected: 'ISSUE-XXX where XXX is 3+ digits',\r\n          suggestion: 'Use format ISSUE-001, ISSUE-002, etc.',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  // Check if frontmatter ID matches heading ID\r\n  const frontmatterId = issue.frontmatter.id;\r\n  if (frontmatterId && frontmatterId !== issue.id) {\r\n    errors.push(\r\n      createIssue(\r\n        'ID_MISMATCH',\r\n        `Issue heading ID '${issue.id}' does not match frontmatter ID '${frontmatterId}'`,\r\n        'error',\r\n        {\r\n          filePath,\r\n          line: issue.lineNumber,\r\n          value: frontmatterId,\r\n          expected: issue.id,\r\n          suggestion: `Update frontmatter 'id' to match heading: ${issue.id}`,\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\n/**\r\n * Validate issue status value\r\n */\r\nfunction validateStatus(\r\n  issue: ParsedIssueItem,\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const warnings: ValidationIssue[] = [];\r\n  const status = issue.frontmatter.status;\r\n\r\n  if (status && typeof status === 'string') {\r\n    if (!VALID_STATUSES.includes(status as typeof VALID_STATUSES[number])) {\r\n      warnings.push(\r\n        createIssue(\r\n          'INVALID_STATUS',\r\n          `Invalid status '${status}' for issue ${issue.id}`,\r\n          'warning',\r\n          {\r\n            filePath,\r\n            line: issue.lineNumber,\r\n            value: status,\r\n            expected: VALID_STATUSES,\r\n            suggestion: `Use one of: ${VALID_STATUSES.join(', ')}`,\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  return warnings;\r\n}\r\n\r\n/**\r\n * Validate issue severity value\r\n */\r\nfunction validateSeverity(\r\n  issue: ParsedIssueItem,\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const warnings: ValidationIssue[] = [];\r\n  const severity = issue.frontmatter.severity;\r\n\r\n  if (severity && typeof severity === 'string') {\r\n    if (!VALID_SEVERITIES.includes(severity as typeof VALID_SEVERITIES[number])) {\r\n      warnings.push(\r\n        createIssue(\r\n          'INVALID_SEVERITY',\r\n          `Invalid severity '${severity}' for issue ${issue.id}`,\r\n          'warning',\r\n          {\r\n            filePath,\r\n            line: issue.lineNumber,\r\n            value: severity,\r\n            expected: VALID_SEVERITIES,\r\n            suggestion: `Use one of: ${VALID_SEVERITIES.join(', ')}`,\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  return warnings;\r\n}\r\n\r\n/**\r\n * Check for missing frontmatter\r\n */\r\nfunction validateHasFrontmatter(\r\n  issue: ParsedIssueItem,\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const warnings: ValidationIssue[] = [];\r\n\r\n  if (!issue.rawYaml || Object.keys(issue.frontmatter).length === 0) {\r\n    warnings.push(\r\n      createIssue(\r\n        'MISSING_FRONTMATTER',\r\n        `Issue ${issue.id} has no YAML frontmatter block`,\r\n        'warning',\r\n        {\r\n          filePath,\r\n          line: issue.lineNumber,\r\n          suggestion: 'Add a YAML code block with issue metadata after the heading',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  return warnings;\r\n}\r\n\r\n/**\r\n * Validate related issue references\r\n */\r\nfunction validateRelatedIssues(\r\n  issue: ParsedIssueItem,\r\n  allIssueIds: Set<string>,\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const warnings: ValidationIssue[] = [];\r\n  const relatedIssues = issue.frontmatter.related_issues;\r\n\r\n  if (Array.isArray(relatedIssues)) {\r\n    for (const relatedId of relatedIssues) {\r\n      if (typeof relatedId === 'string') {\r\n        // Check format\r\n        if (!ISSUE_ID_PATTERN.test(relatedId)) {\r\n          warnings.push(\r\n            createIssue(\r\n              'INVALID_RELATED_ID_FORMAT',\r\n              `Invalid related issue ID format '${relatedId}' in issue ${issue.id}`,\r\n              'warning',\r\n              {\r\n                filePath,\r\n                line: issue.lineNumber,\r\n                value: relatedId,\r\n                suggestion: 'Use format ISSUE-XXX',\r\n              }\r\n            )\r\n          );\r\n        }\r\n\r\n        // Check self-reference\r\n        if (relatedId === issue.id) {\r\n          warnings.push(\r\n            createIssue(\r\n              'SELF_REFERENCE',\r\n              `Issue ${issue.id} references itself in related_issues`,\r\n              'warning',\r\n              {\r\n                filePath,\r\n                line: issue.lineNumber,\r\n                suggestion: 'Remove self-reference from related_issues',\r\n              }\r\n            )\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return warnings;\r\n}\r\n\r\n/**\r\n * Main validation function for ISSUES.md\r\n *\r\n * @param issuesPath - Path to the ISSUES.md file\r\n * @param options - Validation options\r\n * @returns Validation result with errors and warnings\r\n */\r\nexport async function validateIssues(\r\n  issuesPath: string,\r\n  options: ValidationOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n  const resolvedPath = resolve(issuesPath);\r\n\r\n  // Check if file exists\r\n  if (!(await fileExists(resolvedPath))) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'FILE_NOT_FOUND',\r\n        `ISSUES.md file not found at: ${resolvedPath}`,\r\n        'error',\r\n        {\r\n          filePath: resolvedPath,\r\n          suggestion: 'Create an ISSUES.md file or check the path',\r\n        }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Read and parse the file\r\n  let content: string;\r\n  try {\r\n    content = await readTextFile(resolvedPath);\r\n  } catch (error) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'FILE_READ_ERROR',\r\n        `Failed to read ISSUES.md: ${error instanceof Error ? error.message : String(error)}`,\r\n        'error',\r\n        {\r\n          filePath: resolvedPath,\r\n        }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Parse issues from content\r\n  const { issues, parseErrors } = parseIssueItems(content, resolvedPath);\r\n  result.errors.push(...parseErrors);\r\n\r\n  // If no issues found, return early with info message\r\n  if (issues.length === 0) {\r\n    result.info.push(\r\n      createIssue(\r\n        'NO_ISSUES_FOUND',\r\n        'No issue items found in ISSUES.md',\r\n        'info',\r\n        {\r\n          filePath: resolvedPath,\r\n          suggestion: 'Add issues using ### ISSUE-XXX: Title format',\r\n        }\r\n      )\r\n    );\r\n    result.valid = result.errors.length === 0;\r\n    result.duration = Date.now() - startTime;\r\n    result.itemCount = 0;\r\n    return result;\r\n  }\r\n\r\n  // Load schema for validation\r\n  let schema: object | null = null;\r\n  const schemaPath = getDefaultSchemaPath();\r\n\r\n  try {\r\n    if (await fileExists(schemaPath)) {\r\n      schema = await readJsonFile<object>(schemaPath);\r\n    }\r\n  } catch (error) {\r\n    result.warnings.push(\r\n      createIssue(\r\n        'SCHEMA_LOAD_ERROR',\r\n        `Could not load issue schema: ${error instanceof Error ? error.message : String(error)}`,\r\n        'warning',\r\n        {\r\n          filePath: schemaPath,\r\n          suggestion: 'Schema validation will be skipped',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  // Collect all issue IDs for cross-reference validation\r\n  const allIssueIds = new Set(issues.map((i) => i.id));\r\n\r\n  // Validate ID uniqueness first\r\n  result.errors.push(...validateIdUniqueness(issues, resolvedPath));\r\n\r\n  // Validate each issue\r\n  for (const issue of issues) {\r\n    // Validate ID format\r\n    result.errors.push(...validateIdFormat(issue, resolvedPath));\r\n\r\n    // Check for missing frontmatter\r\n    const frontmatterWarnings = validateHasFrontmatter(issue, resolvedPath);\r\n    if (options.includeWarnings !== false) {\r\n      result.warnings.push(...frontmatterWarnings);\r\n    }\r\n\r\n    // Skip further validation if no frontmatter\r\n    if (Object.keys(issue.frontmatter).length === 0) {\r\n      continue;\r\n    }\r\n\r\n    // Validate against schema if available\r\n    if (schema) {\r\n      const schemaResult = validateWithSchema(issue.frontmatter, schema, resolvedPath);\r\n      if (!schemaResult.valid) {\r\n        // Add issue context to error messages\r\n        for (const err of schemaResult.issues) {\r\n          result.errors.push({\r\n            ...err,\r\n            message: `[${issue.id}] ${err.message}`,\r\n            line: issue.lineNumber,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Validate status (even without schema)\r\n    const statusWarnings = validateStatus(issue, resolvedPath);\r\n    if (options.includeWarnings !== false) {\r\n      result.warnings.push(...statusWarnings);\r\n    }\r\n\r\n    // Validate severity (even without schema)\r\n    const severityWarnings = validateSeverity(issue, resolvedPath);\r\n    if (options.includeWarnings !== false) {\r\n      result.warnings.push(...severityWarnings);\r\n    }\r\n\r\n    // Validate related issues\r\n    const relatedWarnings = validateRelatedIssues(issue, allIssueIds, resolvedPath);\r\n    if (options.includeWarnings !== false) {\r\n      result.warnings.push(...relatedWarnings);\r\n    }\r\n\r\n    // Check for max errors\r\n    if (options.maxErrors && result.errors.length >= options.maxErrors) {\r\n      result.warnings.push(\r\n        createIssue(\r\n          'MAX_ERRORS_REACHED',\r\n          `Maximum error count (${options.maxErrors}) reached, stopping validation`,\r\n          'warning',\r\n          {\r\n            filePath: resolvedPath,\r\n          }\r\n        )\r\n      );\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Set final result\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n  result.itemCount = issues.length;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Export the parsed issues for use by other validators/tools\r\n */\r\nexport async function parseIssues(issuesPath: string): Promise<ParsedIssueItem[]> {\r\n  const resolvedPath = resolve(issuesPath);\r\n\r\n  if (!(await fileExists(resolvedPath))) {\r\n    return [];\r\n  }\r\n\r\n  const content = await readTextFile(resolvedPath);\r\n  const { issues } = parseIssueItems(content, resolvedPath);\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Default export for convenience\r\n */\r\nexport default validateIssues;\r\n","/**\r\n * CHANGELOG.md Validator\r\n *\r\n * Validates CHANGELOG.md files against PKF standards including:\r\n * - Frontmatter schema validation (changelog-entry.schema.json)\r\n * - Semver format validation\r\n * - Date format validation\r\n * - Valid change types (added, changed, deprecated, removed, fixed, security)\r\n * - Reverse chronological order verification\r\n */\r\n\r\nimport { readFile } from 'fs/promises';\r\nimport { resolve } from 'path';\r\nimport {\r\n  type ValidationResult,\r\n  type ValidationOptions,\r\n  type ValidationIssue,\r\n  createEmptyResult,\r\n  createIssue,\r\n} from '../types/index.js';\r\nimport { fileExists, readJsonFile } from '../utils/file-utils.js';\r\nimport { validateWithSchema } from '../utils/schema-utils.js';\r\n\r\n/**\r\n * Valid change type categories per Keep a Changelog specification\r\n */\r\nconst VALID_CHANGE_TYPES = [\r\n  'added',\r\n  'changed',\r\n  'deprecated',\r\n  'removed',\r\n  'fixed',\r\n  'security',\r\n] as const;\r\n\r\ntype ChangeType = (typeof VALID_CHANGE_TYPES)[number];\r\n\r\n/**\r\n * Parsed version entry from CHANGELOG.md\r\n */\r\ninterface ParsedVersionEntry {\r\n  /** Raw header text (e.g., \"[1.0.0] - 2025-12-24\") */\r\n  header: string;\r\n  /** Version string (e.g., \"1.0.0\", \"Unreleased\") */\r\n  version: string;\r\n  /** Release date string (e.g., \"2025-12-24\") or null for Unreleased */\r\n  date: string | null;\r\n  /** Line number where the version header appears */\r\n  line: number;\r\n  /** Raw frontmatter YAML content if present */\r\n  frontmatterYaml: string | null;\r\n  /** Parsed frontmatter data */\r\n  frontmatter: Record<string, unknown> | null;\r\n  /** Change sections found (added, changed, etc.) */\r\n  changeSections: Map<string, string[]>;\r\n  /** Raw content of the version section */\r\n  content: string;\r\n}\r\n\r\n/**\r\n * Semver regex pattern\r\n * Matches: major.minor.patch with optional prerelease and build metadata\r\n */\r\nconst SEMVER_PATTERN = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([a-zA-Z0-9.-]+))?(?:\\+([a-zA-Z0-9.-]+))?$/;\r\n\r\n/**\r\n * Version header pattern in Keep a Changelog format\r\n * Matches: ## [version] - YYYY-MM-DD or ## [Unreleased]\r\n */\r\nconst VERSION_HEADER_PATTERN = /^##\\s+\\[([^\\]]+)\\](?:\\s*-\\s*(\\d{4}-\\d{2}-\\d{2}))?/;\r\n\r\n/**\r\n * Change section header pattern\r\n * Matches: ### Added, ### Changed, etc.\r\n */\r\nconst CHANGE_SECTION_PATTERN = /^###\\s+(\\w+)/i;\r\n\r\n/**\r\n * YAML code block pattern for embedded frontmatter\r\n */\r\nconst YAML_BLOCK_PATTERN = /```yaml\\n([\\s\\S]*?)```/;\r\n\r\n/**\r\n * Date format pattern (YYYY-MM-DD)\r\n */\r\nconst DATE_PATTERN = /^\\d{4}-\\d{2}-\\d{2}$/;\r\n\r\n/**\r\n * Parse semver string into components\r\n */\r\nfunction parseSemver(\r\n  version: string\r\n): { major: number; minor: number; patch: number; prerelease: string | null } | null {\r\n  const match = version.match(SEMVER_PATTERN);\r\n  if (!match) return null;\r\n\r\n  const majorStr = match[1];\r\n  const minorStr = match[2];\r\n  const patchStr = match[3];\r\n\r\n  if (majorStr === undefined || minorStr === undefined || patchStr === undefined) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    major: parseInt(majorStr, 10),\r\n    minor: parseInt(minorStr, 10),\r\n    patch: parseInt(patchStr, 10),\r\n    prerelease: match[4] ?? null,\r\n  };\r\n}\r\n\r\n/**\r\n * Compare two semver versions\r\n * Returns: -1 if a < b, 0 if a === b, 1 if a > b\r\n */\r\nfunction compareSemver(a: string, b: string): number {\r\n  const parsedA = parseSemver(a);\r\n  const parsedB = parseSemver(b);\r\n\r\n  // If either is unparseable, can't compare\r\n  if (!parsedA || !parsedB) return 0;\r\n\r\n  // Compare major.minor.patch\r\n  if (parsedA.major !== parsedB.major) {\r\n    return parsedA.major > parsedB.major ? 1 : -1;\r\n  }\r\n  if (parsedA.minor !== parsedB.minor) {\r\n    return parsedA.minor > parsedB.minor ? 1 : -1;\r\n  }\r\n  if (parsedA.patch !== parsedB.patch) {\r\n    return parsedA.patch > parsedB.patch ? 1 : -1;\r\n  }\r\n\r\n  // Prerelease versions have lower precedence\r\n  if (parsedA.prerelease && !parsedB.prerelease) return -1;\r\n  if (!parsedA.prerelease && parsedB.prerelease) return 1;\r\n\r\n  // Both have prereleases, compare alphabetically\r\n  if (parsedA.prerelease && parsedB.prerelease) {\r\n    return parsedA.prerelease.localeCompare(parsedB.prerelease);\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Compare two dates in YYYY-MM-DD format\r\n * Returns: -1 if a < b, 0 if a === b, 1 if a > b\r\n */\r\nfunction compareDates(a: string, b: string): number {\r\n  const dateA = new Date(a);\r\n  const dateB = new Date(b);\r\n\r\n  if (dateA < dateB) return -1;\r\n  if (dateA > dateB) return 1;\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Validate a date string (YYYY-MM-DD format and valid date)\r\n */\r\nfunction isValidDate(dateStr: string): boolean {\r\n  if (!DATE_PATTERN.test(dateStr)) return false;\r\n\r\n  const parts = dateStr.split('-').map(Number);\r\n  const year = parts[0];\r\n  const month = parts[1];\r\n  const day = parts[2];\r\n\r\n  if (year === undefined || month === undefined || day === undefined) {\r\n    return false;\r\n  }\r\n\r\n  const date = new Date(year, month - 1, day);\r\n\r\n  return (\r\n    date.getFullYear() === year &&\r\n    date.getMonth() === month - 1 &&\r\n    date.getDate() === day\r\n  );\r\n}\r\n\r\n/**\r\n * Parse YAML content into an object\r\n */\r\nasync function parseYaml(content: string): Promise<Record<string, unknown>> {\r\n  const { parse } = await import('yaml');\r\n  return parse(content) as Record<string, unknown>;\r\n}\r\n\r\n/**\r\n * Parse CHANGELOG.md content into version entries\r\n */\r\nasync function parseChangelogContent(\r\n  content: string,\r\n  filePath: string\r\n): Promise<{ entries: ParsedVersionEntry[]; issues: ValidationIssue[] }> {\r\n  const lines = content.split('\\n');\r\n  const entries: ParsedVersionEntry[] = [];\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  let currentEntry: ParsedVersionEntry | null = null;\r\n  let currentSection: string | null = null;\r\n  let sectionContent: string[] = [];\r\n  let entryContentLines: string[] = [];\r\n  let inYamlBlock = false;\r\n  let yamlLines: string[] = [];\r\n\r\n  const finalizeCurrentEntry = () => {\r\n    if (currentEntry) {\r\n      // Save last section\r\n      if (currentSection && sectionContent.length > 0) {\r\n        currentEntry.changeSections.set(currentSection.toLowerCase(), sectionContent);\r\n      }\r\n      currentEntry.content = entryContentLines.join('\\n');\r\n      entries.push(currentEntry);\r\n    }\r\n  };\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const line = lines[i] ?? '';\r\n    const lineNumber = i + 1;\r\n\r\n    // Track YAML code blocks\r\n    if (line.trim() === '```yaml') {\r\n      inYamlBlock = true;\r\n      yamlLines = [];\r\n      continue;\r\n    }\r\n\r\n    if (inYamlBlock && line.trim() === '```') {\r\n      inYamlBlock = false;\r\n      if (currentEntry && yamlLines.length > 0) {\r\n        currentEntry.frontmatterYaml = yamlLines.join('\\n');\r\n        try {\r\n          currentEntry.frontmatter = await parseYaml(currentEntry.frontmatterYaml);\r\n        } catch (error) {\r\n          issues.push(\r\n            createIssue(\r\n              'YAML_PARSE_ERROR',\r\n              `Failed to parse YAML frontmatter: ${error instanceof Error ? error.message : String(error)}`,\r\n              'error',\r\n              { filePath, line: lineNumber }\r\n            )\r\n          );\r\n        }\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (inYamlBlock) {\r\n      yamlLines.push(line);\r\n      continue;\r\n    }\r\n\r\n    // Check for version header\r\n    const versionMatch = line.match(VERSION_HEADER_PATTERN);\r\n    if (versionMatch) {\r\n      finalizeCurrentEntry();\r\n\r\n      const version = versionMatch[1] ?? '';\r\n      const date = versionMatch[2] ?? null;\r\n\r\n      currentEntry = {\r\n        header: line,\r\n        version,\r\n        date,\r\n        line: lineNumber,\r\n        frontmatterYaml: null,\r\n        frontmatter: null,\r\n        changeSections: new Map(),\r\n        content: '',\r\n      };\r\n      currentSection = null;\r\n      sectionContent = [];\r\n      entryContentLines = [];\r\n      continue;\r\n    }\r\n\r\n    // Check for change section header\r\n    const sectionMatch = line.match(CHANGE_SECTION_PATTERN);\r\n    if (sectionMatch && currentEntry) {\r\n      // Save previous section\r\n      if (currentSection && sectionContent.length > 0) {\r\n        currentEntry.changeSections.set(currentSection.toLowerCase(), sectionContent);\r\n      }\r\n      currentSection = sectionMatch[1] ?? null;\r\n      sectionContent = [];\r\n      entryContentLines.push(line);\r\n      continue;\r\n    }\r\n\r\n    // Collect section items (list items starting with -)\r\n    if (currentSection && line.trim().startsWith('-')) {\r\n      const item = line.trim().substring(1).trim();\r\n      if (item) {\r\n        sectionContent.push(item);\r\n      }\r\n    }\r\n\r\n    if (currentEntry) {\r\n      entryContentLines.push(line);\r\n    }\r\n  }\r\n\r\n  // Finalize last entry\r\n  finalizeCurrentEntry();\r\n\r\n  return { entries, issues };\r\n}\r\n\r\n/**\r\n * Validate a single changelog entry\r\n */\r\nasync function validateEntry(\r\n  entry: ParsedVersionEntry,\r\n  schema: object,\r\n  filePath: string,\r\n  options: ValidationOptions\r\n): Promise<ValidationIssue[]> {\r\n  const issues: ValidationIssue[] = [];\r\n  const isUnreleased = entry.version.toLowerCase() === 'unreleased';\r\n\r\n  // Validate version format\r\n  if (!isUnreleased) {\r\n    if (!SEMVER_PATTERN.test(entry.version)) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_SEMVER',\r\n          `Version \"${entry.version}\" is not a valid semantic version`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            value: entry.version,\r\n            expected: 'major.minor.patch[-prerelease][+build]',\r\n            suggestion: 'Use semantic versioning format (e.g., 1.0.0, 1.0.0-alpha.1)',\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // Validate date presence and format for released versions\r\n  if (!isUnreleased) {\r\n    if (!entry.date) {\r\n      issues.push(\r\n        createIssue(\r\n          'MISSING_DATE',\r\n          `Released version ${entry.version} is missing a release date`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            suggestion: 'Add date in format: ## [version] - YYYY-MM-DD',\r\n          }\r\n        )\r\n      );\r\n    } else if (!isValidDate(entry.date)) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_DATE',\r\n          `Invalid date \"${entry.date}\" for version ${entry.version}`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            value: entry.date,\r\n            expected: 'YYYY-MM-DD format with valid date',\r\n            suggestion: 'Use a valid date in YYYY-MM-DD format',\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // Validate change section types\r\n  for (const [sectionType] of entry.changeSections) {\r\n    const normalizedType = sectionType.toLowerCase();\r\n    if (!VALID_CHANGE_TYPES.includes(normalizedType as ChangeType)) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_CHANGE_TYPE',\r\n          `Invalid change type \"${sectionType}\" in version ${entry.version}`,\r\n          'warning',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            value: sectionType,\r\n            expected: VALID_CHANGE_TYPES,\r\n            suggestion: `Use one of: ${VALID_CHANGE_TYPES.join(', ')}`,\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // Validate frontmatter against schema if present\r\n  if (entry.frontmatter) {\r\n    const schemaResult = validateWithSchema(entry.frontmatter, schema, filePath);\r\n    if (!schemaResult.valid) {\r\n      for (const issue of schemaResult.issues) {\r\n        issue.line = entry.line;\r\n        issues.push(issue);\r\n      }\r\n    }\r\n\r\n    // Cross-validate frontmatter with header info\r\n    const fmVersion = entry.frontmatter.version as string | undefined;\r\n    const fmDate = entry.frontmatter.date as string | null | undefined;\r\n    const fmStatus = entry.frontmatter.status as string | undefined;\r\n\r\n    // Version mismatch check\r\n    if (fmVersion && fmVersion.toLowerCase() !== entry.version.toLowerCase()) {\r\n      issues.push(\r\n        createIssue(\r\n          'VERSION_MISMATCH',\r\n          `Frontmatter version \"${fmVersion}\" does not match header version \"${entry.version}\"`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            suggestion: 'Ensure frontmatter version matches the section header version',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    // Date mismatch check\r\n    if (entry.date && fmDate && fmDate !== entry.date) {\r\n      issues.push(\r\n        createIssue(\r\n          'DATE_MISMATCH',\r\n          `Frontmatter date \"${fmDate}\" does not match header date \"${entry.date}\"`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            suggestion: 'Ensure frontmatter date matches the section header date',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    // Status consistency check\r\n    if (isUnreleased && fmStatus && fmStatus !== 'unreleased') {\r\n      issues.push(\r\n        createIssue(\r\n          'STATUS_MISMATCH',\r\n          `Unreleased section has status \"${fmStatus}\" instead of \"unreleased\"`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            suggestion: 'Set status to \"unreleased\" for unreleased versions',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    if (!isUnreleased && fmStatus && fmStatus !== 'released') {\r\n      issues.push(\r\n        createIssue(\r\n          'STATUS_MISMATCH',\r\n          `Released version ${entry.version} has status \"${fmStatus}\" instead of \"released\"`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: entry.line,\r\n            suggestion: 'Set status to \"released\" for released versions',\r\n          }\r\n        )\r\n      );\r\n    }\r\n  } else if (options.strict) {\r\n    // In strict mode, require frontmatter\r\n    issues.push(\r\n      createIssue(\r\n        'MISSING_FRONTMATTER',\r\n        `Version ${entry.version} is missing YAML frontmatter`,\r\n        'warning',\r\n        {\r\n          filePath,\r\n          line: entry.line,\r\n          suggestion: 'Add YAML frontmatter block with version, type, status, and date fields',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  // Check for empty version with no changes\r\n  const hasChanges = Array.from(entry.changeSections.values()).some(\r\n    (items) => items.length > 0 && items.some((item) => item.trim() !== '')\r\n  );\r\n  if (!hasChanges && !isUnreleased) {\r\n    issues.push(\r\n      createIssue(\r\n        'EMPTY_VERSION',\r\n        `Version ${entry.version} has no documented changes`,\r\n        'warning',\r\n        {\r\n          filePath,\r\n          line: entry.line,\r\n          suggestion: 'Add changes under Added, Changed, Fixed, etc. sections',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Validate chronological order of entries\r\n * Entries should be in reverse chronological order (newest first)\r\n */\r\nfunction validateChronologicalOrder(\r\n  entries: ParsedVersionEntry[],\r\n  filePath: string\r\n): ValidationIssue[] {\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  // Filter out Unreleased entry for ordering checks\r\n  const releasedEntries = entries.filter(\r\n    (e) => e.version.toLowerCase() !== 'unreleased'\r\n  );\r\n\r\n  // Check that Unreleased is first if present\r\n  const unreleasedEntry = entries.find(\r\n    (e) => e.version.toLowerCase() === 'unreleased'\r\n  );\r\n  if (unreleasedEntry && entries.indexOf(unreleasedEntry) !== 0) {\r\n    issues.push(\r\n      createIssue(\r\n        'UNRELEASED_NOT_FIRST',\r\n        'Unreleased section should be the first version entry',\r\n        'error',\r\n        {\r\n          filePath,\r\n          line: unreleasedEntry.line,\r\n          suggestion: 'Move the [Unreleased] section to the top of the version list',\r\n        }\r\n      )\r\n    );\r\n  }\r\n\r\n  // Check version order (should be descending)\r\n  for (let i = 0; i < releasedEntries.length - 1; i++) {\r\n    const current = releasedEntries[i];\r\n    const next = releasedEntries[i + 1];\r\n\r\n    // Skip if either entry is undefined (shouldn't happen, but TypeScript needs this)\r\n    if (!current || !next) continue;\r\n\r\n    const versionComparison = compareSemver(current.version, next.version);\r\n    if (versionComparison < 0) {\r\n      issues.push(\r\n        createIssue(\r\n          'VERSION_ORDER',\r\n          `Version ${current.version} appears before ${next.version} but should be after (newer versions first)`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: current.line,\r\n            suggestion:\r\n              'Arrange versions in reverse chronological order (newest first)',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    // Check date order if both have dates\r\n    if (current.date && next.date) {\r\n      const dateComparison = compareDates(current.date, next.date);\r\n      if (dateComparison < 0) {\r\n        issues.push(\r\n          createIssue(\r\n            'DATE_ORDER',\r\n            `Date ${current.date} (version ${current.version}) is earlier than ${next.date} (version ${next.version})`,\r\n            'error',\r\n            {\r\n              filePath,\r\n              line: current.line,\r\n              suggestion:\r\n                'Arrange versions in reverse chronological order by date',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Load the changelog entry schema\r\n */\r\nasync function loadChangelogSchema(\r\n  rootDir?: string\r\n): Promise<object> {\r\n  // Try to find schema in common locations\r\n  const schemaPaths = [\r\n    rootDir ? resolve(rootDir, 'schemas/changelog-entry.schema.json') : null,\r\n    resolve(process.cwd(), 'schemas/changelog-entry.schema.json'),\r\n    resolve(process.cwd(), '../../schemas/changelog-entry.schema.json'),\r\n  ].filter((p): p is string => p !== null);\r\n\r\n  for (const schemaPath of schemaPaths) {\r\n    if (await fileExists(schemaPath)) {\r\n      return readJsonFile(schemaPath);\r\n    }\r\n  }\r\n\r\n  // Return a minimal fallback schema if none found\r\n  return {\r\n    type: 'object',\r\n    required: ['version', 'type', 'status'],\r\n    properties: {\r\n      version: { type: 'string' },\r\n      type: { type: 'string', const: 'changelog-entry' },\r\n      status: { type: 'string', enum: ['unreleased', 'released'] },\r\n      date: { type: ['string', 'null'] },\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Validate a CHANGELOG.md file\r\n *\r\n * @param changelogPath - Path to the CHANGELOG.md file\r\n * @param options - Validation options\r\n * @returns Validation result with all errors and warnings\r\n */\r\nexport async function validateChangelog(\r\n  changelogPath: string,\r\n  options: ValidationOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n  const resolvedPath = resolve(changelogPath);\r\n\r\n  try {\r\n    // Check file exists\r\n    if (!(await fileExists(resolvedPath))) {\r\n      result.errors.push(\r\n        createIssue('FILE_NOT_FOUND', `Changelog file not found: ${resolvedPath}`, 'error', {\r\n          filePath: resolvedPath,\r\n        })\r\n      );\r\n      result.valid = false;\r\n      result.duration = Date.now() - startTime;\r\n      return result;\r\n    }\r\n\r\n    // Read file content\r\n    const content = await readFile(resolvedPath, 'utf-8');\r\n\r\n    // Load schema\r\n    const schema = await loadChangelogSchema(options.rootDir);\r\n\r\n    // Parse changelog content\r\n    const { entries, issues: parseIssues } = await parseChangelogContent(\r\n      content,\r\n      resolvedPath\r\n    );\r\n\r\n    // Add parse issues\r\n    for (const issue of parseIssues) {\r\n      if (issue.severity === 'error') {\r\n        result.errors.push(issue);\r\n      } else if (issue.severity === 'warning') {\r\n        result.warnings.push(issue);\r\n      } else {\r\n        result.info.push(issue);\r\n      }\r\n    }\r\n\r\n    // Validate no entries found\r\n    if (entries.length === 0) {\r\n      result.warnings.push(\r\n        createIssue(\r\n          'NO_VERSIONS',\r\n          'No version entries found in changelog',\r\n          'warning',\r\n          {\r\n            filePath: resolvedPath,\r\n            suggestion: 'Add version sections using format: ## [1.0.0] - YYYY-MM-DD',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    // Validate each entry\r\n    for (const entry of entries) {\r\n      const entryIssues = await validateEntry(entry, schema, resolvedPath, options);\r\n\r\n      for (const issue of entryIssues) {\r\n        if (issue.severity === 'error') {\r\n          result.errors.push(issue);\r\n        } else if (issue.severity === 'warning') {\r\n          result.warnings.push(issue);\r\n        } else {\r\n          result.info.push(issue);\r\n        }\r\n      }\r\n\r\n      // Check max errors limit\r\n      if (options.maxErrors && result.errors.length >= options.maxErrors) {\r\n        result.info.push(\r\n          createIssue(\r\n            'MAX_ERRORS_REACHED',\r\n            `Stopped validation after reaching ${options.maxErrors} errors`,\r\n            'info',\r\n            { filePath: resolvedPath }\r\n          )\r\n        );\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Validate chronological order\r\n    const orderIssues = validateChronologicalOrder(entries, resolvedPath);\r\n    for (const issue of orderIssues) {\r\n      if (issue.severity === 'error') {\r\n        result.errors.push(issue);\r\n      } else if (issue.severity === 'warning') {\r\n        result.warnings.push(issue);\r\n      } else {\r\n        result.info.push(issue);\r\n      }\r\n    }\r\n\r\n    // Set final result\r\n    result.valid = result.errors.length === 0;\r\n    result.itemCount = entries.length;\r\n    result.duration = Date.now() - startTime;\r\n\r\n    // Filter results based on options\r\n    if (!options.includeWarnings) {\r\n      // Warnings are included by default, only remove if explicitly set to false\r\n      if (options.includeWarnings === false) {\r\n        result.warnings = [];\r\n      }\r\n    }\r\n    if (!options.includeInfo && options.includeInfo !== undefined) {\r\n      result.info = [];\r\n    }\r\n\r\n    return result;\r\n  } catch (error) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'VALIDATION_ERROR',\r\n        `Failed to validate changelog: ${error instanceof Error ? error.message : String(error)}`,\r\n        'error',\r\n        { filePath: resolvedPath }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Changelog Validator class implementing the Validator interface\r\n */\r\nexport const changelogValidator = {\r\n  name: 'changelog-validator',\r\n  description:\r\n    'Validates CHANGELOG.md files against PKF standards including semver, dates, and change types',\r\n\r\n  async validate(\r\n    changelogPath: string,\r\n    options?: ValidationOptions\r\n  ): Promise<ValidationResult> {\r\n    return validateChangelog(changelogPath, options);\r\n  },\r\n};\r\n\r\nexport default validateChangelog;\r\n","/**\r\n * PKF Frontmatter Validator\r\n *\r\n * Validates YAML frontmatter blocks in markdown files against JSON schemas.\r\n * Supports both standard --- delimited frontmatter and ```yaml code blocks.\r\n */\r\n\r\nimport { parse as parseYaml } from 'yaml';\r\nimport {\r\n  type ValidationResult,\r\n  type ValidationOptions,\r\n  type ValidationIssue,\r\n  createEmptyResult,\r\n  createIssue,\r\n} from '../types/index.js';\r\nimport { fileExists, readTextFile, readJsonFile } from '../utils/index.js';\r\nimport { validateWithSchema } from '../utils/schema-utils.js';\r\n\r\n/**\r\n * Result of extracting frontmatter from content\r\n */\r\nexport interface ExtractedFrontmatter {\r\n  /** Parsed frontmatter data, or null if none found */\r\n  data: Record<string, unknown> | null;\r\n  /** Raw YAML string, or null if none found */\r\n  raw: string | null;\r\n  /** Line number where frontmatter starts (1-based) */\r\n  line: number;\r\n  /** The type of frontmatter block found */\r\n  type: 'standard' | 'codeblock' | 'none';\r\n}\r\n\r\n/**\r\n * Options for frontmatter validation\r\n */\r\nexport interface FrontmatterValidationOptions extends ValidationOptions {\r\n  /** Path to the JSON schema file for validation */\r\n  schemaPath?: string;\r\n  /** Inline schema object (takes precedence over schemaPath) */\r\n  schema?: object;\r\n  /** Whether to validate common fields even without a schema */\r\n  validateCommonFields?: boolean;\r\n  /** Required frontmatter fields */\r\n  requiredFields?: string[];\r\n  /** Expected document type (validates against 'type' field in frontmatter) */\r\n  expectedType?: string;\r\n  /** Whether to allow additional properties not defined in schema */\r\n  allowAdditionalProperties?: boolean;\r\n}\r\n\r\n/**\r\n * Common frontmatter fields and their expected types/patterns\r\n */\r\nconst COMMON_FIELD_VALIDATORS: Record<\r\n  string,\r\n  {\r\n    type: string;\r\n    pattern?: RegExp;\r\n    description: string;\r\n    enumValues?: string[];\r\n  }\r\n> = {\r\n  type: {\r\n    type: 'string',\r\n    description: 'Document type identifier',\r\n  },\r\n  title: {\r\n    type: 'string',\r\n    description: 'Document title',\r\n  },\r\n  version: {\r\n    type: 'string',\r\n    pattern: /^\\d+\\.\\d+\\.\\d+(-[\\w.]+)?(\\+[\\w.]+)?$/,\r\n    description: 'SemVer version string (e.g., 1.0.0)',\r\n  },\r\n  status: {\r\n    type: 'string',\r\n    enumValues: ['draft', 'review', 'approved', 'deprecated', 'archived', 'active', 'inactive'],\r\n    description: 'Document status',\r\n  },\r\n  date: {\r\n    type: 'string',\r\n    pattern: /^\\d{4}-\\d{2}-\\d{2}$/,\r\n    description: 'Date in YYYY-MM-DD format',\r\n  },\r\n  created: {\r\n    type: 'string',\r\n    pattern: /^\\d{4}-\\d{2}-\\d{2}$/,\r\n    description: 'Creation date in YYYY-MM-DD format',\r\n  },\r\n  updated: {\r\n    type: 'string',\r\n    pattern: /^\\d{4}-\\d{2}-\\d{2}$/,\r\n    description: 'Last updated date in YYYY-MM-DD format',\r\n  },\r\n  author: {\r\n    type: 'string',\r\n    description: 'Document author',\r\n  },\r\n  authors: {\r\n    type: 'array',\r\n    description: 'List of document authors',\r\n  },\r\n  tags: {\r\n    type: 'array',\r\n    description: 'Document tags',\r\n  },\r\n  labels: {\r\n    type: 'array',\r\n    description: 'Document labels',\r\n  },\r\n  description: {\r\n    type: 'string',\r\n    description: 'Document description',\r\n  },\r\n  id: {\r\n    type: 'string',\r\n    pattern: /^[A-Z]+-\\d+$/,\r\n    description: 'Document identifier (e.g., TODO-001, ADR-001)',\r\n  },\r\n  priority: {\r\n    type: 'string',\r\n    enumValues: ['critical', 'high', 'medium', 'low'],\r\n    description: 'Priority level',\r\n  },\r\n  severity: {\r\n    type: 'string',\r\n    enumValues: ['critical', 'high', 'medium', 'low'],\r\n    description: 'Severity level',\r\n  },\r\n};\r\n\r\n/**\r\n * Extract YAML frontmatter from markdown content\r\n *\r\n * Supports two formats:\r\n * 1. Standard frontmatter: Content starting with --- delimiter\r\n * 2. YAML code block: ```yaml or ```yml at the start of the file\r\n *\r\n * @param content - The markdown content to extract frontmatter from\r\n * @returns Extracted frontmatter data, raw string, and line number\r\n */\r\nexport function extractFrontmatter(content: string): ExtractedFrontmatter {\r\n  const lines = content.split('\\n');\r\n\r\n  // Try standard --- delimited frontmatter first\r\n  const standardResult = extractStandardFrontmatter(lines);\r\n  if (standardResult.data !== null) {\r\n    return standardResult;\r\n  }\r\n\r\n  // Try ```yaml code block at the start\r\n  const codeBlockResult = extractCodeBlockFrontmatter(lines);\r\n  if (codeBlockResult.data !== null) {\r\n    return codeBlockResult;\r\n  }\r\n\r\n  // No frontmatter found\r\n  return {\r\n    data: null,\r\n    raw: null,\r\n    line: 1,\r\n    type: 'none',\r\n  };\r\n}\r\n\r\n/**\r\n * Extract standard --- delimited frontmatter\r\n */\r\nfunction extractStandardFrontmatter(lines: string[]): ExtractedFrontmatter {\r\n  // Check if content starts with ---\r\n  if (lines.length === 0 || lines[0]?.trim() !== '---') {\r\n    return { data: null, raw: null, line: 1, type: 'none' };\r\n  }\r\n\r\n  // Find the closing ---\r\n  let endLine = -1;\r\n  for (let i = 1; i < lines.length; i++) {\r\n    if (lines[i]?.trim() === '---') {\r\n      endLine = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (endLine === -1) {\r\n    // No closing delimiter found\r\n    return { data: null, raw: null, line: 1, type: 'none' };\r\n  }\r\n\r\n  // Extract the YAML content (lines 1 to endLine-1, 0-indexed)\r\n  const yamlLines = lines.slice(1, endLine);\r\n  const rawYaml = yamlLines.join('\\n');\r\n\r\n  try {\r\n    const data = parseYaml(rawYaml) as Record<string, unknown>;\r\n    return {\r\n      data: data || {},\r\n      raw: rawYaml,\r\n      line: 2, // Frontmatter content starts at line 2 (after ---)\r\n      type: 'standard',\r\n    };\r\n  } catch {\r\n    // Return with null data but indicate we found frontmatter structure\r\n    return {\r\n      data: null,\r\n      raw: rawYaml,\r\n      line: 2,\r\n      type: 'standard',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Extract frontmatter from ```yaml code block at the start of the file\r\n */\r\nfunction extractCodeBlockFrontmatter(lines: string[]): ExtractedFrontmatter {\r\n  // Skip empty lines at the start\r\n  let startIndex = 0;\r\n  while (startIndex < lines.length && lines[startIndex]?.trim() === '') {\r\n    startIndex++;\r\n  }\r\n\r\n  // Check if content starts with ```yaml or ```yml\r\n  const firstLine = lines[startIndex] || '';\r\n  const yamlBlockPattern = /^```ya?ml\\s*$/i;\r\n\r\n  if (!yamlBlockPattern.test(firstLine)) {\r\n    return { data: null, raw: null, line: 1, type: 'none' };\r\n  }\r\n\r\n  // Find the closing ```\r\n  let endLine = -1;\r\n  for (let i = startIndex + 1; i < lines.length; i++) {\r\n    if (lines[i]?.trim() === '```') {\r\n      endLine = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (endLine === -1) {\r\n    // No closing delimiter found\r\n    return { data: null, raw: null, line: startIndex + 1, type: 'none' };\r\n  }\r\n\r\n  // Extract the YAML content\r\n  const yamlLines = lines.slice(startIndex + 1, endLine);\r\n  const rawYaml = yamlLines.join('\\n');\r\n\r\n  try {\r\n    const data = parseYaml(rawYaml) as Record<string, unknown>;\r\n    return {\r\n      data: data || {},\r\n      raw: rawYaml,\r\n      line: startIndex + 2, // Content starts after ```yaml line (1-based)\r\n      type: 'codeblock',\r\n    };\r\n  } catch {\r\n    return {\r\n      data: null,\r\n      raw: rawYaml,\r\n      line: startIndex + 2,\r\n      type: 'codeblock',\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Validate frontmatter content against a schema and common field rules\r\n *\r\n * @param content - The markdown content containing frontmatter\r\n * @param schema - JSON schema object to validate against\r\n * @param filePath - Optional file path for error reporting\r\n * @returns Validation result with errors, warnings, and info\r\n */\r\nexport function validateFrontmatterContent(\r\n  content: string,\r\n  schema: object,\r\n  filePath?: string\r\n): ValidationResult {\r\n  const result = createEmptyResult();\r\n  const startTime = Date.now();\r\n\r\n  // Extract frontmatter\r\n  const extracted = extractFrontmatter(content);\r\n\r\n  if (extracted.data === null) {\r\n    if (extracted.raw !== null) {\r\n      // We found frontmatter structure but failed to parse it\r\n      result.errors.push(\r\n        createIssue(\r\n          'FRONTMATTER_PARSE_ERROR',\r\n          'Failed to parse YAML frontmatter',\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: extracted.line,\r\n            suggestion: 'Check YAML syntax for errors',\r\n          }\r\n        )\r\n      );\r\n    } else {\r\n      // No frontmatter found\r\n      result.warnings.push(\r\n        createIssue(\r\n          'NO_FRONTMATTER',\r\n          'No frontmatter found in document',\r\n          'warning',\r\n          {\r\n            filePath,\r\n            suggestion: 'Add frontmatter at the start of the document using --- delimiters',\r\n          }\r\n        )\r\n      );\r\n    }\r\n\r\n    result.valid = result.errors.length === 0;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Validate against schema\r\n  const schemaResult = validateWithSchema(extracted.data, schema, filePath);\r\n\r\n  if (!schemaResult.valid) {\r\n    // Add line information to schema errors\r\n    for (const issue of schemaResult.issues) {\r\n      result.errors.push({\r\n        ...issue,\r\n        line: issue.line ?? extracted.line,\r\n      });\r\n    }\r\n  }\r\n\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n  result.itemCount = 1;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Validate a markdown file's frontmatter\r\n *\r\n * @param filePath - Path to the markdown file\r\n * @param options - Validation options\r\n * @returns Validation result with errors, warnings, and info\r\n */\r\nexport async function validateFrontmatter(\r\n  filePath: string,\r\n  options: FrontmatterValidationOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n\r\n  const {\r\n    schemaPath,\r\n    schema: inlineSchema,\r\n    validateCommonFields = true,\r\n    requiredFields = [],\r\n    expectedType,\r\n    includeWarnings = true,\r\n    includeInfo = true,\r\n  } = options;\r\n\r\n  // Check if file exists\r\n  if (!(await fileExists(filePath))) {\r\n    result.errors.push(\r\n      createIssue('FILE_NOT_FOUND', `File not found: ${filePath}`, 'error', {\r\n        filePath,\r\n      })\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Read file content\r\n  let content: string;\r\n  try {\r\n    content = await readTextFile(filePath);\r\n  } catch (error) {\r\n    result.errors.push(\r\n      createIssue(\r\n        'FILE_READ_ERROR',\r\n        `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,\r\n        'error',\r\n        { filePath }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  // Extract frontmatter\r\n  const extracted = extractFrontmatter(content);\r\n\r\n  if (extracted.data === null) {\r\n    if (extracted.raw !== null) {\r\n      // Found structure but failed to parse\r\n      result.errors.push(\r\n        createIssue(\r\n          'FRONTMATTER_PARSE_ERROR',\r\n          'Failed to parse YAML frontmatter',\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: extracted.line,\r\n            suggestion: 'Check YAML syntax for errors',\r\n          }\r\n        )\r\n      );\r\n    } else {\r\n      // No frontmatter found\r\n      if (requiredFields.length > 0 || inlineSchema || schemaPath) {\r\n        result.errors.push(\r\n          createIssue(\r\n            'NO_FRONTMATTER',\r\n            'Document is missing required frontmatter',\r\n            'error',\r\n            {\r\n              filePath,\r\n              suggestion: 'Add frontmatter at the start of the document using --- delimiters',\r\n            }\r\n          )\r\n        );\r\n      } else if (includeWarnings) {\r\n        result.warnings.push(\r\n          createIssue(\r\n            'NO_FRONTMATTER',\r\n            'No frontmatter found in document',\r\n            'warning',\r\n            {\r\n              filePath,\r\n              suggestion: 'Consider adding frontmatter for better document organization',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    result.valid = result.errors.length === 0;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  const frontmatterData = extracted.data;\r\n\r\n  // Report frontmatter type found\r\n  if (includeInfo) {\r\n    result.info.push(\r\n      createIssue(\r\n        'FRONTMATTER_FOUND',\r\n        `Found ${extracted.type} frontmatter starting at line ${extracted.line}`,\r\n        'info',\r\n        { filePath, line: extracted.line }\r\n      )\r\n    );\r\n  }\r\n\r\n  // Load and validate against schema if provided\r\n  let schema: object | null = null;\r\n\r\n  if (inlineSchema) {\r\n    schema = inlineSchema;\r\n  } else if (schemaPath) {\r\n    if (!(await fileExists(schemaPath))) {\r\n      result.errors.push(\r\n        createIssue(\r\n          'SCHEMA_NOT_FOUND',\r\n          `Schema file not found: ${schemaPath}`,\r\n          'error',\r\n          {\r\n            filePath: schemaPath,\r\n            suggestion: 'Ensure the schema file exists at the specified path',\r\n          }\r\n        )\r\n      );\r\n    } else {\r\n      try {\r\n        schema = await readJsonFile<object>(schemaPath);\r\n      } catch (error) {\r\n        result.errors.push(\r\n          createIssue(\r\n            'SCHEMA_LOAD_ERROR',\r\n            `Failed to load schema: ${error instanceof Error ? error.message : String(error)}`,\r\n            'error',\r\n            { filePath: schemaPath }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Validate against schema\r\n  if (schema) {\r\n    const schemaResult = validateWithSchema(frontmatterData, schema, filePath);\r\n\r\n    if (!schemaResult.valid) {\r\n      for (const issue of schemaResult.issues) {\r\n        result.errors.push({\r\n          ...issue,\r\n          line: issue.line ?? extracted.line,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check required fields\r\n  for (const field of requiredFields) {\r\n    if (!(field in frontmatterData)) {\r\n      result.errors.push(\r\n        createIssue(\r\n          'REQUIRED_FIELD_MISSING',\r\n          `Required frontmatter field '${field}' is missing`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: extracted.line,\r\n            suggestion: `Add the '${field}' field to the frontmatter`,\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // Check expected type\r\n  if (expectedType && frontmatterData.type !== expectedType) {\r\n    if (!frontmatterData.type) {\r\n      result.errors.push(\r\n        createIssue(\r\n          'TYPE_MISSING',\r\n          `Document is missing 'type' field, expected '${expectedType}'`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: extracted.line,\r\n            suggestion: `Add 'type: ${expectedType}' to the frontmatter`,\r\n          }\r\n        )\r\n      );\r\n    } else {\r\n      result.errors.push(\r\n        createIssue(\r\n          'TYPE_MISMATCH',\r\n          `Document type '${frontmatterData.type}' does not match expected type '${expectedType}'`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line: extracted.line,\r\n            value: frontmatterData.type,\r\n            expected: expectedType,\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // Validate common fields\r\n  if (validateCommonFields && !schema) {\r\n    const commonFieldIssues = validateCommonFrontmatterFields(\r\n      frontmatterData,\r\n      filePath,\r\n      extracted.line,\r\n      includeWarnings\r\n    );\r\n    categorizeIssues(commonFieldIssues, result);\r\n  }\r\n\r\n  // Additional semantic validations\r\n  const semanticIssues = validateSemanticRules(\r\n    frontmatterData,\r\n    filePath,\r\n    extracted.line,\r\n    includeWarnings\r\n  );\r\n  categorizeIssues(semanticIssues, result);\r\n\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n  result.itemCount = 1;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Validate common frontmatter fields against expected types and patterns\r\n */\r\nfunction validateCommonFrontmatterFields(\r\n  data: Record<string, unknown>,\r\n  filePath: string | undefined,\r\n  line: number,\r\n  includeWarnings: boolean\r\n): ValidationIssue[] {\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  for (const [field, value] of Object.entries(data)) {\r\n    const validator = COMMON_FIELD_VALIDATORS[field];\r\n    if (!validator) {\r\n      continue; // Skip unknown fields in common validation\r\n    }\r\n\r\n    // Type check\r\n    const actualType = Array.isArray(value) ? 'array' : typeof value;\r\n    if (actualType !== validator.type) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_FIELD_TYPE',\r\n          `Field '${field}' should be ${validator.type}, got ${actualType}`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line,\r\n            value,\r\n            expected: validator.type,\r\n            suggestion: validator.description,\r\n          }\r\n        )\r\n      );\r\n      continue;\r\n    }\r\n\r\n    // Pattern check for strings\r\n    if (validator.pattern && typeof value === 'string') {\r\n      if (!validator.pattern.test(value)) {\r\n        issues.push(\r\n          createIssue(\r\n            'INVALID_FIELD_FORMAT',\r\n            `Field '${field}' does not match expected format: ${validator.description}`,\r\n            'error',\r\n            {\r\n              filePath,\r\n              line,\r\n              value,\r\n              expected: validator.pattern.source,\r\n              suggestion: validator.description,\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // Enum check\r\n    if (validator.enumValues && typeof value === 'string') {\r\n      if (!validator.enumValues.includes(value)) {\r\n        if (includeWarnings) {\r\n          issues.push(\r\n            createIssue(\r\n              'UNKNOWN_ENUM_VALUE',\r\n              `Field '${field}' has unexpected value '${value}'. Common values: ${validator.enumValues.join(', ')}`,\r\n              'warning',\r\n              {\r\n                filePath,\r\n                line,\r\n                value,\r\n                expected: validator.enumValues,\r\n                suggestion: `Consider using one of: ${validator.enumValues.join(', ')}`,\r\n              }\r\n            )\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Validate semantic rules across frontmatter fields\r\n */\r\nfunction validateSemanticRules(\r\n  data: Record<string, unknown>,\r\n  filePath: string | undefined,\r\n  line: number,\r\n  includeWarnings: boolean\r\n): ValidationIssue[] {\r\n  const issues: ValidationIssue[] = [];\r\n\r\n  // Check date ordering: created <= updated\r\n  const created = data.created as string | undefined;\r\n  const updated = data.updated as string | undefined;\r\n\r\n  if (created && updated && isValidDateFormat(created) && isValidDateFormat(updated)) {\r\n    if (updated < created) {\r\n      if (includeWarnings) {\r\n        issues.push(\r\n          createIssue(\r\n            'DATE_ORDER_WARNING',\r\n            `'updated' date (${updated}) is before 'created' date (${created})`,\r\n            'warning',\r\n            {\r\n              filePath,\r\n              line,\r\n              value: { created, updated },\r\n              suggestion: 'Update the dates so that updated >= created',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check date ordering: date <= updated (if both present)\r\n  const date = data.date as string | undefined;\r\n  if (date && updated && isValidDateFormat(date) && isValidDateFormat(updated)) {\r\n    if (updated < date) {\r\n      if (includeWarnings) {\r\n        issues.push(\r\n          createIssue(\r\n            'DATE_ORDER_WARNING',\r\n            `'updated' date (${updated}) is before 'date' field (${date})`,\r\n            'warning',\r\n            {\r\n              filePath,\r\n              line,\r\n              value: { date, updated },\r\n              suggestion: 'Check if the dates are correct',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for empty required-like fields\r\n  const importantStringFields = ['title', 'description', 'author', 'type'];\r\n  for (const field of importantStringFields) {\r\n    const value = data[field];\r\n    if (typeof value === 'string' && value.trim() === '') {\r\n      if (includeWarnings) {\r\n        issues.push(\r\n          createIssue(\r\n            'EMPTY_FIELD',\r\n            `Field '${field}' is empty`,\r\n            'warning',\r\n            {\r\n              filePath,\r\n              line,\r\n              value,\r\n              suggestion: `Provide a meaningful value for '${field}' or remove the field`,\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check for empty arrays\r\n  const arrayFields = ['tags', 'labels', 'authors'];\r\n  for (const field of arrayFields) {\r\n    const value = data[field];\r\n    if (Array.isArray(value) && value.length === 0) {\r\n      if (includeWarnings) {\r\n        issues.push(\r\n          createIssue(\r\n            'EMPTY_ARRAY',\r\n            `Field '${field}' is an empty array`,\r\n            'warning',\r\n            {\r\n              filePath,\r\n              line,\r\n              suggestion: `Add items to '${field}' or remove the field`,\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // Validate version is valid semver if present\r\n  const version = data.version;\r\n  if (typeof version === 'string') {\r\n    if (!/^\\d+\\.\\d+\\.\\d+(-[\\w.]+)?(\\+[\\w.]+)?$/.test(version)) {\r\n      issues.push(\r\n        createIssue(\r\n          'INVALID_VERSION',\r\n          `Version '${version}' is not a valid SemVer string`,\r\n          'error',\r\n          {\r\n            filePath,\r\n            line,\r\n            value: version,\r\n            expected: 'SemVer format (e.g., 1.0.0, 1.0.0-alpha.1)',\r\n            suggestion: 'Use SemVer format: MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]',\r\n          }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // Validate dates are real dates\r\n  const dateFields = ['date', 'created', 'updated'];\r\n  for (const field of dateFields) {\r\n    const value = data[field];\r\n    if (typeof value === 'string') {\r\n      if (!isValidDate(value)) {\r\n        issues.push(\r\n          createIssue(\r\n            'INVALID_DATE',\r\n            `Field '${field}' contains invalid date: ${value}`,\r\n            'error',\r\n            {\r\n              filePath,\r\n              line,\r\n              value,\r\n              expected: 'YYYY-MM-DD format with valid date values',\r\n              suggestion: 'Use a valid date in YYYY-MM-DD format (e.g., 2025-01-15)',\r\n            }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return issues;\r\n}\r\n\r\n/**\r\n * Check if a string matches YYYY-MM-DD format\r\n */\r\nfunction isValidDateFormat(dateStr: string): boolean {\r\n  return /^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr);\r\n}\r\n\r\n/**\r\n * Check if a date string is a valid date\r\n */\r\nfunction isValidDate(dateStr: string): boolean {\r\n  if (!isValidDateFormat(dateStr)) {\r\n    return false;\r\n  }\r\n\r\n  const parts = dateStr.split('-').map(Number);\r\n  const year = parts[0];\r\n  const month = parts[1];\r\n  const day = parts[2];\r\n\r\n  if (year === undefined || month === undefined || day === undefined) {\r\n    return false;\r\n  }\r\n\r\n  // Check valid ranges\r\n  if (month < 1 || month > 12 || day < 1 || day > 31) {\r\n    return false;\r\n  }\r\n\r\n  // Check actual date validity\r\n  const date = new Date(year, month - 1, day);\r\n\r\n  return (\r\n    date.getFullYear() === year &&\r\n    date.getMonth() === month - 1 &&\r\n    date.getDate() === day\r\n  );\r\n}\r\n\r\n/**\r\n * Categorize issues into the result object by severity\r\n */\r\nfunction categorizeIssues(\r\n  issues: ValidationIssue[],\r\n  result: ValidationResult\r\n): void {\r\n  for (const issue of issues) {\r\n    switch (issue.severity) {\r\n      case 'error':\r\n        result.errors.push(issue);\r\n        break;\r\n      case 'warning':\r\n        result.warnings.push(issue);\r\n        break;\r\n      case 'info':\r\n        result.info.push(issue);\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Batch validate multiple files' frontmatter\r\n *\r\n * @param filePaths - Array of file paths to validate\r\n * @param options - Validation options (applied to all files)\r\n * @returns Aggregated validation result\r\n */\r\nexport async function validateMultipleFrontmatter(\r\n  filePaths: string[],\r\n  options: FrontmatterValidationOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n\r\n  for (const filePath of filePaths) {\r\n    const fileResult = await validateFrontmatter(filePath, options);\r\n\r\n    result.errors.push(...fileResult.errors);\r\n    result.warnings.push(...fileResult.warnings);\r\n    result.info.push(...fileResult.info);\r\n\r\n    if (fileResult.itemCount) {\r\n      result.itemCount = (result.itemCount ?? 0) + fileResult.itemCount;\r\n    }\r\n  }\r\n\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Create a frontmatter schema for a specific document type\r\n *\r\n * @param docType - The document type name\r\n * @param requiredFields - Fields required for this document type\r\n * @param additionalProperties - Additional schema properties\r\n * @returns JSON Schema object\r\n */\r\nexport function createFrontmatterSchema(\r\n  docType: string,\r\n  requiredFields: string[] = ['type', 'title'],\r\n  additionalProperties: Record<string, object> = {}\r\n): object {\r\n  return {\r\n    $schema: 'http://json-schema.org/draft-07/schema#',\r\n    $id: `pkf-frontmatter-${docType}.schema.json`,\r\n    type: 'object',\r\n    required: requiredFields,\r\n    properties: {\r\n      type: {\r\n        type: 'string',\r\n        const: docType,\r\n        description: 'Document type identifier',\r\n      },\r\n      title: {\r\n        type: 'string',\r\n        minLength: 1,\r\n        description: 'Document title',\r\n      },\r\n      version: {\r\n        type: 'string',\r\n        pattern: '^\\\\d+\\\\.\\\\d+\\\\.\\\\d+(-[\\\\w.]+)?(\\\\+[\\\\w.]+)?$',\r\n        description: 'SemVer version string',\r\n      },\r\n      status: {\r\n        type: 'string',\r\n        enum: ['draft', 'review', 'approved', 'deprecated', 'archived', 'active', 'inactive'],\r\n        description: 'Document status',\r\n      },\r\n      date: {\r\n        type: 'string',\r\n        pattern: '^\\\\d{4}-\\\\d{2}-\\\\d{2}$',\r\n        description: 'Date in YYYY-MM-DD format',\r\n      },\r\n      created: {\r\n        type: 'string',\r\n        pattern: '^\\\\d{4}-\\\\d{2}-\\\\d{2}$',\r\n        description: 'Creation date',\r\n      },\r\n      updated: {\r\n        type: 'string',\r\n        pattern: '^\\\\d{4}-\\\\d{2}-\\\\d{2}$',\r\n        description: 'Last update date',\r\n      },\r\n      author: {\r\n        type: 'string',\r\n        description: 'Document author',\r\n      },\r\n      authors: {\r\n        type: 'array',\r\n        items: { type: 'string' },\r\n        description: 'List of authors',\r\n      },\r\n      description: {\r\n        type: 'string',\r\n        description: 'Document description',\r\n      },\r\n      tags: {\r\n        type: 'array',\r\n        items: { type: 'string' },\r\n        description: 'Document tags',\r\n      },\r\n      ...additionalProperties,\r\n    },\r\n    additionalProperties: true,\r\n  };\r\n}\r\n\r\nexport default validateFrontmatter;\r\n","/**\r\n * PKF Schema DSL Parser\r\n *\r\n * Parses PKF Schema DSL (YAML-based) files and converts them to JSON Schema format.\r\n * Supports schema inheritance via _extends, field definitions with types and constraints,\r\n * and generates valid JSON Schema draft-07 output.\r\n *\r\n * @see docs/framework/specifications/PKF-SCHEMA-DSL.md\r\n */\r\n\r\nimport { parse as parseYaml } from 'yaml';\r\nimport {\r\n  createEmptyResult,\r\n  createIssue,\r\n  type ValidationResult,\r\n  type ValidationOptions,\r\n  type ValidationIssue,\r\n} from '../types/index.js';\r\nimport { fileExists, readTextFile, readYamlFile } from '../utils/index.js';\r\n\r\n// ============================================================================\r\n// Type Definitions\r\n// ============================================================================\r\n\r\n/**\r\n * Supported property types in PKF Schema DSL\r\n */\r\nexport type SchemaPropertyType = 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object';\r\n\r\n/**\r\n * Array item definition for array-type properties\r\n */\r\nexport interface SchemaArrayItems {\r\n  type: SchemaPropertyType;\r\n  enum?: unknown[];\r\n  pattern?: string;\r\n}\r\n\r\n/**\r\n * A single field/property definition in a schema\r\n */\r\nexport interface SchemaField {\r\n  /** Field name */\r\n  name: string;\r\n  /** Field type */\r\n  type: SchemaPropertyType;\r\n  /** Whether the field is required */\r\n  required: boolean;\r\n  /** Human-readable description */\r\n  description?: string;\r\n  /** Default value or placeholder */\r\n  defaultValue?: unknown;\r\n  /** Allowed values (for enums) */\r\n  enum?: unknown[];\r\n  /** Regex pattern for string validation */\r\n  pattern?: string;\r\n  /** Minimum value (for numbers) */\r\n  minimum?: number;\r\n  /** Maximum value (for numbers) */\r\n  maximum?: number;\r\n  /** Minimum string length */\r\n  minLength?: number;\r\n  /** Maximum string length */\r\n  maxLength?: number;\r\n  /** Array item schema */\r\n  items?: SchemaArrayItems;\r\n  /** Minimum array length */\r\n  minItems?: number;\r\n  /** Maximum array length */\r\n  maxItems?: number;\r\n  /** Whether array items must be unique */\r\n  uniqueItems?: boolean;\r\n}\r\n\r\n/**\r\n * Metadata for a schema definition\r\n */\r\nexport interface SchemaMetadata {\r\n  /** Human-readable description */\r\n  description?: string;\r\n  /** Example file paths */\r\n  examples?: string[];\r\n  /** Whether this schema is deprecated */\r\n  deprecated?: boolean;\r\n  /** Schema version */\r\n  version?: string;\r\n}\r\n\r\n/**\r\n * A complete schema definition\r\n */\r\nexport interface SchemaDefinition {\r\n  /** Schema name (identifier) */\r\n  name: string;\r\n  /** Parent schema to extend from */\r\n  extends?: string;\r\n  /** Field definitions */\r\n  fields: SchemaField[];\r\n  /** Schema metadata */\r\n  metadata: SchemaMetadata;\r\n}\r\n\r\n/**\r\n * Inheritance relationship between schemas\r\n */\r\nexport interface SchemaRelationship {\r\n  /** Child schema name */\r\n  child: string;\r\n  /** Parent schema name */\r\n  parent: string;\r\n}\r\n\r\n/**\r\n * Result of parsing a Schema DSL file\r\n */\r\nexport interface ParsedSchemaDSL {\r\n  /** DSL version */\r\n  version: string;\r\n  /** Parsed schema definitions */\r\n  schemas: Map<string, SchemaDefinition>;\r\n  /** Inheritance relationships */\r\n  relationships: SchemaRelationship[];\r\n  /** Schemas with resolved inheritance (fields from parents merged) */\r\n  resolvedSchemas: Map<string, SchemaDefinition>;\r\n}\r\n\r\n/**\r\n * Raw property definition as it appears in the YAML\r\n */\r\ninterface RawPropertyDefinition {\r\n  type: string;\r\n  required?: boolean;\r\n  description?: string;\r\n  default?: unknown;\r\n  enum?: unknown[];\r\n  pattern?: string;\r\n  minimum?: number;\r\n  maximum?: number;\r\n  minLength?: number;\r\n  maxLength?: number;\r\n  items?: {\r\n    type?: string;\r\n    enum?: unknown[];\r\n    pattern?: string;\r\n  };\r\n  minItems?: number;\r\n  maxItems?: number;\r\n  uniqueItems?: boolean;\r\n}\r\n\r\n/**\r\n * Raw schema definition as it appears in the YAML\r\n */\r\ninterface RawSchemaDefinition {\r\n  _extends?: string;\r\n  _description?: string;\r\n  _examples?: string[];\r\n  _deprecated?: boolean;\r\n  _version?: string;\r\n  properties?: Record<string, RawPropertyDefinition>;\r\n}\r\n\r\n/**\r\n * Raw DSL file structure\r\n */\r\ninterface RawSchemaDSL {\r\n  version: string;\r\n  schemas: Record<string, RawSchemaDefinition>;\r\n}\r\n\r\n// ============================================================================\r\n// SchemaDSLParser Class\r\n// ============================================================================\r\n\r\n/**\r\n * Parser for PKF Schema DSL files\r\n *\r\n * Parses YAML-based schema definitions and converts them to internal\r\n * schema representation and JSON Schema format.\r\n */\r\nexport class SchemaDSLParser {\r\n  private rawDSL: RawSchemaDSL | null = null;\r\n  private parsed: ParsedSchemaDSL | null = null;\r\n  private errors: ValidationIssue[] = [];\r\n  private filePath: string | null = null;\r\n\r\n  /**\r\n   * Parse Schema DSL from a YAML string\r\n   *\r\n   * @param yamlContent - YAML content to parse\r\n   * @param filePath - Optional file path for error reporting\r\n   * @returns Parsed schema DSL or null if parsing failed\r\n   */\r\n  parse(yamlContent: string, filePath?: string): ParsedSchemaDSL | null {\r\n    this.errors = [];\r\n    this.filePath = filePath || null;\r\n\r\n    try {\r\n      // Parse YAML\r\n      const raw = parseYaml(yamlContent) as RawSchemaDSL;\r\n      this.rawDSL = raw;\r\n\r\n      // Validate basic structure\r\n      if (!this.validateStructure(raw)) {\r\n        return null;\r\n      }\r\n\r\n      // Parse schemas\r\n      const schemas = this.parseSchemas(raw.schemas);\r\n      if (!schemas) {\r\n        return null;\r\n      }\r\n\r\n      // Build relationships\r\n      const relationships = this.buildRelationships(schemas);\r\n\r\n      // Resolve inheritance\r\n      const resolvedSchemas = this.resolveInheritance(schemas, relationships);\r\n      if (!resolvedSchemas) {\r\n        return null;\r\n      }\r\n\r\n      this.parsed = {\r\n        version: raw.version,\r\n        schemas,\r\n        relationships,\r\n        resolvedSchemas,\r\n      };\r\n\r\n      return this.parsed;\r\n    } catch (error) {\r\n      this.addError(\r\n        'DSL_PARSE_ERROR',\r\n        `Failed to parse Schema DSL: ${error instanceof Error ? error.message : String(error)}`\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse Schema DSL from a file\r\n   *\r\n   * @param filePath - Path to the YAML file\r\n   * @returns Parsed schema DSL or null if parsing failed\r\n   */\r\n  async parseFile(filePath: string): Promise<ParsedSchemaDSL | null> {\r\n    this.filePath = filePath;\r\n    this.errors = [];\r\n\r\n    if (!(await fileExists(filePath))) {\r\n      this.addError('FILE_NOT_FOUND', `Schema DSL file not found: ${filePath}`);\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const content = await readTextFile(filePath);\r\n      return this.parse(content, filePath);\r\n    } catch (error) {\r\n      this.addError(\r\n        'FILE_READ_ERROR',\r\n        `Failed to read Schema DSL file: ${error instanceof Error ? error.message : String(error)}`\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get parsing errors\r\n   */\r\n  getErrors(): ValidationIssue[] {\r\n    return [...this.errors];\r\n  }\r\n\r\n  /**\r\n   * Get the last parsed result\r\n   */\r\n  getResult(): ParsedSchemaDSL | null {\r\n    return this.parsed;\r\n  }\r\n\r\n  /**\r\n   * Convert a parsed schema to JSON Schema format\r\n   *\r\n   * @param schemaName - Name of the schema to convert\r\n   * @param useResolved - Whether to use resolved (inheritance merged) schema\r\n   * @returns JSON Schema object or null if schema not found\r\n   */\r\n  toJsonSchema(schemaName: string, useResolved: boolean = true): object | null {\r\n    if (!this.parsed) {\r\n      return null;\r\n    }\r\n\r\n    const schemaMap = useResolved ? this.parsed.resolvedSchemas : this.parsed.schemas;\r\n    const schema = schemaMap.get(schemaName);\r\n\r\n    if (!schema) {\r\n      return null;\r\n    }\r\n\r\n    return this.schemaDefinitionToJsonSchema(schema);\r\n  }\r\n\r\n  /**\r\n   * Convert all parsed schemas to JSON Schema format\r\n   *\r\n   * @param useResolved - Whether to use resolved (inheritance merged) schemas\r\n   * @returns Map of schema names to JSON Schema objects\r\n   */\r\n  toAllJsonSchemas(useResolved: boolean = true): Map<string, object> {\r\n    const result = new Map<string, object>();\r\n\r\n    if (!this.parsed) {\r\n      return result;\r\n    }\r\n\r\n    const schemaMap = useResolved ? this.parsed.resolvedSchemas : this.parsed.schemas;\r\n\r\n    for (const [name, schema] of schemaMap) {\r\n      const jsonSchema = this.schemaDefinitionToJsonSchema(schema);\r\n      result.set(name, jsonSchema);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Private Methods\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Add an error to the error list\r\n   */\r\n  private addError(code: string, message: string, line?: number): void {\r\n    this.errors.push(\r\n      createIssue(code, message, 'error', {\r\n        filePath: this.filePath || undefined,\r\n        line,\r\n      })\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Validate the basic structure of the raw DSL\r\n   */\r\n  private validateStructure(raw: RawSchemaDSL): boolean {\r\n    if (!raw || typeof raw !== 'object') {\r\n      this.addError('INVALID_STRUCTURE', 'Schema DSL must be a valid YAML object');\r\n      return false;\r\n    }\r\n\r\n    if (!raw.version) {\r\n      this.addError('MISSING_VERSION', 'Schema DSL must have a \"version\" field');\r\n      return false;\r\n    }\r\n\r\n    if (!/^\\d+\\.\\d+$/.test(raw.version)) {\r\n      this.addError(\r\n        'INVALID_VERSION',\r\n        `Invalid version format: \"${raw.version}\". Expected format: \"X.Y\" (e.g., \"1.0\")`\r\n      );\r\n      return false;\r\n    }\r\n\r\n    if (!raw.schemas || typeof raw.schemas !== 'object') {\r\n      this.addError('MISSING_SCHEMAS', 'Schema DSL must have a \"schemas\" object');\r\n      return false;\r\n    }\r\n\r\n    if (Object.keys(raw.schemas).length === 0) {\r\n      this.addError('EMPTY_SCHEMAS', 'Schema DSL must define at least one schema');\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Parse all schema definitions\r\n   */\r\n  private parseSchemas(\r\n    rawSchemas: Record<string, RawSchemaDefinition>\r\n  ): Map<string, SchemaDefinition> | null {\r\n    const schemas = new Map<string, SchemaDefinition>();\r\n    let hasErrors = false;\r\n\r\n    for (const [name, rawSchema] of Object.entries(rawSchemas)) {\r\n      // Validate schema name format\r\n      if (!/^[a-z][a-z0-9-]*$/.test(name)) {\r\n        this.addError(\r\n          'INVALID_SCHEMA_NAME',\r\n          `Invalid schema name: \"${name}\". Must be lowercase alphanumeric with hyphens, starting with a letter.`\r\n        );\r\n        hasErrors = true;\r\n        continue;\r\n      }\r\n\r\n      const schema = this.parseSchemaDefinition(name, rawSchema);\r\n      if (schema) {\r\n        schemas.set(name, schema);\r\n      } else {\r\n        hasErrors = true;\r\n      }\r\n    }\r\n\r\n    return hasErrors && schemas.size === 0 ? null : schemas;\r\n  }\r\n\r\n  /**\r\n   * Parse a single schema definition\r\n   */\r\n  private parseSchemaDefinition(\r\n    name: string,\r\n    raw: RawSchemaDefinition\r\n  ): SchemaDefinition | null {\r\n    if (!raw || typeof raw !== 'object') {\r\n      this.addError('INVALID_SCHEMA', `Schema \"${name}\" must be an object`);\r\n      return null;\r\n    }\r\n\r\n    // Parse metadata\r\n    const metadata: SchemaMetadata = {\r\n      description: raw._description,\r\n      examples: raw._examples,\r\n      deprecated: raw._deprecated,\r\n      version: raw._version,\r\n    };\r\n\r\n    // Parse fields from properties\r\n    const fields: SchemaField[] = [];\r\n\r\n    if (raw.properties && typeof raw.properties === 'object') {\r\n      for (const [propName, propDef] of Object.entries(raw.properties)) {\r\n        // Validate property name format\r\n        if (!/^[a-z][a-z0-9_-]*$/.test(propName)) {\r\n          this.addError(\r\n            'INVALID_PROPERTY_NAME',\r\n            `Invalid property name \"${propName}\" in schema \"${name}\". Must be lowercase alphanumeric with hyphens/underscores, starting with a letter.`\r\n          );\r\n          continue;\r\n        }\r\n\r\n        const field = this.parseFieldDefinition(name, propName, propDef);\r\n        if (field) {\r\n          fields.push(field);\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      name,\r\n      extends: raw._extends,\r\n      fields,\r\n      metadata,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parse a single field definition\r\n   */\r\n  private parseFieldDefinition(\r\n    schemaName: string,\r\n    fieldName: string,\r\n    raw: RawPropertyDefinition\r\n  ): SchemaField | null {\r\n    if (!raw || typeof raw !== 'object') {\r\n      this.addError(\r\n        'INVALID_PROPERTY',\r\n        `Property \"${fieldName}\" in schema \"${schemaName}\" must be an object`\r\n      );\r\n      return null;\r\n    }\r\n\r\n    if (!raw.type) {\r\n      this.addError(\r\n        'MISSING_TYPE',\r\n        `Property \"${fieldName}\" in schema \"${schemaName}\" must have a \"type\" field`\r\n      );\r\n      return null;\r\n    }\r\n\r\n    const validTypes: SchemaPropertyType[] = ['string', 'number', 'boolean', 'date', 'array', 'object'];\r\n    if (!validTypes.includes(raw.type as SchemaPropertyType)) {\r\n      this.addError(\r\n        'INVALID_TYPE',\r\n        `Property \"${fieldName}\" in schema \"${schemaName}\" has invalid type \"${raw.type}\". ` +\r\n          `Must be one of: ${validTypes.join(', ')}`\r\n      );\r\n      return null;\r\n    }\r\n\r\n    const field: SchemaField = {\r\n      name: fieldName,\r\n      type: raw.type as SchemaPropertyType,\r\n      required: raw.required ?? false,\r\n      description: raw.description,\r\n      defaultValue: raw.default,\r\n      enum: raw.enum,\r\n      pattern: raw.pattern,\r\n      minimum: raw.minimum,\r\n      maximum: raw.maximum,\r\n      minLength: raw.minLength,\r\n      maxLength: raw.maxLength,\r\n      minItems: raw.minItems,\r\n      maxItems: raw.maxItems,\r\n      uniqueItems: raw.uniqueItems,\r\n    };\r\n\r\n    // Parse array items if present\r\n    if (raw.type === 'array' && raw.items) {\r\n      field.items = {\r\n        type: (raw.items.type as SchemaPropertyType) || 'string',\r\n        enum: raw.items.enum,\r\n        pattern: raw.items.pattern,\r\n      };\r\n    }\r\n\r\n    // Validate constraints based on type\r\n    this.validateFieldConstraints(schemaName, field);\r\n\r\n    return field;\r\n  }\r\n\r\n  /**\r\n   * Validate field constraints are appropriate for the field type\r\n   */\r\n  private validateFieldConstraints(schemaName: string, field: SchemaField): void {\r\n    const { name, type } = field;\r\n\r\n    // String-specific constraints\r\n    if (type !== 'string' && type !== 'date') {\r\n      if (field.pattern !== undefined) {\r\n        this.errors.push(\r\n          createIssue(\r\n            'INVALID_CONSTRAINT',\r\n            `Property \"${name}\" in schema \"${schemaName}\": \"pattern\" is only valid for string/date types`,\r\n            'warning',\r\n            { filePath: this.filePath || undefined }\r\n          )\r\n        );\r\n      }\r\n      if (field.minLength !== undefined || field.maxLength !== undefined) {\r\n        this.errors.push(\r\n          createIssue(\r\n            'INVALID_CONSTRAINT',\r\n            `Property \"${name}\" in schema \"${schemaName}\": \"minLength/maxLength\" are only valid for string types`,\r\n            'warning',\r\n            { filePath: this.filePath || undefined }\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // Number-specific constraints\r\n    if (type !== 'number') {\r\n      if (field.minimum !== undefined || field.maximum !== undefined) {\r\n        this.errors.push(\r\n          createIssue(\r\n            'INVALID_CONSTRAINT',\r\n            `Property \"${name}\" in schema \"${schemaName}\": \"minimum/maximum\" are only valid for number types`,\r\n            'warning',\r\n            { filePath: this.filePath || undefined }\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // Array-specific constraints\r\n    if (type !== 'array') {\r\n      if (field.items !== undefined || field.minItems !== undefined ||\r\n          field.maxItems !== undefined || field.uniqueItems !== undefined) {\r\n        this.errors.push(\r\n          createIssue(\r\n            'INVALID_CONSTRAINT',\r\n            `Property \"${name}\" in schema \"${schemaName}\": array constraints are only valid for array types`,\r\n            'warning',\r\n            { filePath: this.filePath || undefined }\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build inheritance relationships from parsed schemas\r\n   */\r\n  private buildRelationships(schemas: Map<string, SchemaDefinition>): SchemaRelationship[] {\r\n    const relationships: SchemaRelationship[] = [];\r\n\r\n    for (const [name, schema] of schemas) {\r\n      if (schema.extends) {\r\n        relationships.push({\r\n          child: name,\r\n          parent: schema.extends,\r\n        });\r\n      }\r\n    }\r\n\r\n    return relationships;\r\n  }\r\n\r\n  /**\r\n   * Resolve schema inheritance by merging parent fields into children\r\n   */\r\n  private resolveInheritance(\r\n    schemas: Map<string, SchemaDefinition>,\r\n    relationships: SchemaRelationship[]\r\n  ): Map<string, SchemaDefinition> | null {\r\n    const resolved = new Map<string, SchemaDefinition>();\r\n    const visited = new Set<string>();\r\n    const visiting = new Set<string>();\r\n\r\n    // Validate all extends references exist\r\n    for (const rel of relationships) {\r\n      if (!schemas.has(rel.parent)) {\r\n        this.addError(\r\n          'UNKNOWN_PARENT',\r\n          `Schema \"${rel.child}\" extends unknown schema \"${rel.parent}\"`\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Resolve each schema (topological sort via DFS)\r\n    const resolveSchema = (name: string): SchemaDefinition | null => {\r\n      if (resolved.has(name)) {\r\n        return resolved.get(name)!;\r\n      }\r\n\r\n      if (visiting.has(name)) {\r\n        this.addError(\r\n          'CIRCULAR_INHERITANCE',\r\n          `Circular inheritance detected involving schema \"${name}\"`\r\n        );\r\n        return null;\r\n      }\r\n\r\n      const schema = schemas.get(name);\r\n      if (!schema) {\r\n        return null;\r\n      }\r\n\r\n      visiting.add(name);\r\n\r\n      let resolvedFields: SchemaField[];\r\n\r\n      if (schema.extends) {\r\n        // First resolve the parent\r\n        const parentResolved = resolveSchema(schema.extends);\r\n        if (!parentResolved) {\r\n          visiting.delete(name);\r\n          return null;\r\n        }\r\n\r\n        // Merge fields: parent fields first, then child fields (child overrides)\r\n        const fieldMap = new Map<string, SchemaField>();\r\n\r\n        for (const field of parentResolved.fields) {\r\n          fieldMap.set(field.name, { ...field });\r\n        }\r\n\r\n        for (const field of schema.fields) {\r\n          fieldMap.set(field.name, { ...field });\r\n        }\r\n\r\n        resolvedFields = Array.from(fieldMap.values());\r\n      } else {\r\n        resolvedFields = schema.fields.map(f => ({ ...f }));\r\n      }\r\n\r\n      const resolvedSchema: SchemaDefinition = {\r\n        name: schema.name,\r\n        extends: schema.extends,\r\n        fields: resolvedFields,\r\n        metadata: { ...schema.metadata },\r\n      };\r\n\r\n      visiting.delete(name);\r\n      visited.add(name);\r\n      resolved.set(name, resolvedSchema);\r\n\r\n      return resolvedSchema;\r\n    };\r\n\r\n    // Resolve all schemas\r\n    for (const name of schemas.keys()) {\r\n      if (!resolveSchema(name)) {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return resolved;\r\n  }\r\n\r\n  /**\r\n   * Convert a SchemaDefinition to JSON Schema format\r\n   */\r\n  private schemaDefinitionToJsonSchema(schema: SchemaDefinition): object {\r\n    const jsonSchema: Record<string, unknown> = {\r\n      $schema: 'http://json-schema.org/draft-07/schema#',\r\n      type: 'object',\r\n    };\r\n\r\n    // Add metadata\r\n    if (schema.metadata.description) {\r\n      jsonSchema.description = schema.metadata.description;\r\n    }\r\n\r\n    // Collect required fields and build properties\r\n    const required: string[] = [];\r\n    const properties: Record<string, object> = {};\r\n\r\n    for (const field of schema.fields) {\r\n      if (field.required) {\r\n        required.push(field.name);\r\n      }\r\n      properties[field.name] = this.fieldToJsonSchemaProperty(field);\r\n    }\r\n\r\n    if (required.length > 0) {\r\n      jsonSchema.required = required;\r\n    }\r\n\r\n    if (Object.keys(properties).length > 0) {\r\n      jsonSchema.properties = properties;\r\n    }\r\n\r\n    return jsonSchema;\r\n  }\r\n\r\n  /**\r\n   * Convert a SchemaField to a JSON Schema property definition\r\n   */\r\n  private fieldToJsonSchemaProperty(field: SchemaField): object {\r\n    const prop: Record<string, unknown> = {};\r\n\r\n    // Map PKF types to JSON Schema types\r\n    switch (field.type) {\r\n      case 'string':\r\n        prop.type = 'string';\r\n        break;\r\n      case 'number':\r\n        prop.type = 'number';\r\n        break;\r\n      case 'boolean':\r\n        prop.type = 'boolean';\r\n        break;\r\n      case 'date':\r\n        // Date is represented as a string with format\r\n        prop.type = 'string';\r\n        prop.format = 'date';\r\n        break;\r\n      case 'array':\r\n        prop.type = 'array';\r\n        break;\r\n      case 'object':\r\n        prop.type = 'object';\r\n        break;\r\n    }\r\n\r\n    // Add description\r\n    if (field.description) {\r\n      prop.description = field.description;\r\n    }\r\n\r\n    // Add default value (skip placeholders for JSON Schema)\r\n    if (field.defaultValue !== undefined) {\r\n      const defaultStr = String(field.defaultValue);\r\n      // Skip placeholder defaults like {{TODAY}}, {{GIT_USER}}\r\n      if (!defaultStr.startsWith('{{') || !defaultStr.endsWith('}}')) {\r\n        prop.default = field.defaultValue;\r\n      }\r\n    }\r\n\r\n    // Add enum\r\n    if (field.enum && field.enum.length > 0) {\r\n      prop.enum = field.enum;\r\n    }\r\n\r\n    // Add pattern (for string types)\r\n    if (field.pattern && (field.type === 'string' || field.type === 'date')) {\r\n      prop.pattern = field.pattern;\r\n    }\r\n\r\n    // Add number constraints\r\n    if (field.type === 'number') {\r\n      if (field.minimum !== undefined) {\r\n        prop.minimum = field.minimum;\r\n      }\r\n      if (field.maximum !== undefined) {\r\n        prop.maximum = field.maximum;\r\n      }\r\n    }\r\n\r\n    // Add string length constraints\r\n    if (field.type === 'string') {\r\n      if (field.minLength !== undefined) {\r\n        prop.minLength = field.minLength;\r\n      }\r\n      if (field.maxLength !== undefined) {\r\n        prop.maxLength = field.maxLength;\r\n      }\r\n    }\r\n\r\n    // Add array constraints\r\n    if (field.type === 'array') {\r\n      if (field.items) {\r\n        const itemSchema: Record<string, unknown> = {\r\n          type: field.items.type === 'date' ? 'string' : field.items.type,\r\n        };\r\n        if (field.items.type === 'date') {\r\n          itemSchema.format = 'date';\r\n        }\r\n        if (field.items.enum) {\r\n          itemSchema.enum = field.items.enum;\r\n        }\r\n        if (field.items.pattern) {\r\n          itemSchema.pattern = field.items.pattern;\r\n        }\r\n        prop.items = itemSchema;\r\n      }\r\n      if (field.minItems !== undefined) {\r\n        prop.minItems = field.minItems;\r\n      }\r\n      if (field.maxItems !== undefined) {\r\n        prop.maxItems = field.maxItems;\r\n      }\r\n      if (field.uniqueItems !== undefined) {\r\n        prop.uniqueItems = field.uniqueItems;\r\n      }\r\n    }\r\n\r\n    return prop;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Standalone Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Parse Schema DSL from YAML content\r\n *\r\n * @param yamlContent - YAML content to parse\r\n * @param filePath - Optional file path for error reporting\r\n * @returns Object containing parsed result and any errors\r\n */\r\nexport function parseSchemasDSL(\r\n  yamlContent: string,\r\n  filePath?: string\r\n): { result: ParsedSchemaDSL | null; errors: ValidationIssue[] } {\r\n  const parser = new SchemaDSLParser();\r\n  const result = parser.parse(yamlContent, filePath);\r\n  return {\r\n    result,\r\n    errors: parser.getErrors(),\r\n  };\r\n}\r\n\r\n/**\r\n * Parse Schema DSL from a file\r\n *\r\n * @param filePath - Path to the YAML file\r\n * @returns Object containing parsed result and any errors\r\n */\r\nexport async function parseSchemasDSLFile(\r\n  filePath: string\r\n): Promise<{ result: ParsedSchemaDSL | null; errors: ValidationIssue[] }> {\r\n  const parser = new SchemaDSLParser();\r\n  const result = await parser.parseFile(filePath);\r\n  return {\r\n    result,\r\n    errors: parser.getErrors(),\r\n  };\r\n}\r\n\r\n/**\r\n * Convert Schema DSL YAML to JSON Schema\r\n *\r\n * @param yamlContent - YAML content to parse\r\n * @param schemaName - Optional specific schema name to convert (converts all if not specified)\r\n * @param useResolved - Whether to use resolved (inheritance merged) schemas\r\n * @returns Map of schema names to JSON Schema objects, or null on error\r\n */\r\nexport function schemaDSLToJsonSchema(\r\n  yamlContent: string,\r\n  schemaName?: string,\r\n  useResolved: boolean = true\r\n): { schemas: Map<string, object> | null; errors: ValidationIssue[] } {\r\n  const parser = new SchemaDSLParser();\r\n  const parseResult = parser.parse(yamlContent);\r\n\r\n  if (!parseResult) {\r\n    return {\r\n      schemas: null,\r\n      errors: parser.getErrors(),\r\n    };\r\n  }\r\n\r\n  if (schemaName) {\r\n    const jsonSchema = parser.toJsonSchema(schemaName, useResolved);\r\n    if (!jsonSchema) {\r\n      return {\r\n        schemas: null,\r\n        errors: [\r\n          createIssue('SCHEMA_NOT_FOUND', `Schema \"${schemaName}\" not found in DSL`, 'error'),\r\n        ],\r\n      };\r\n    }\r\n    const result = new Map<string, object>();\r\n    result.set(schemaName, jsonSchema);\r\n    return { schemas: result, errors: [] };\r\n  }\r\n\r\n  return {\r\n    schemas: parser.toAllJsonSchemas(useResolved),\r\n    errors: parser.getErrors(),\r\n  };\r\n}\r\n\r\n/**\r\n * Validate Schema DSL content\r\n *\r\n * @param yamlContent - YAML content to validate\r\n * @param filePath - Optional file path for error reporting\r\n * @returns ValidationResult with errors, warnings, and info\r\n */\r\nexport function validateSchemaDSL(\r\n  yamlContent: string,\r\n  filePath?: string\r\n): ValidationResult {\r\n  const startTime = Date.now();\r\n  const result = createEmptyResult();\r\n\r\n  const parser = new SchemaDSLParser();\r\n  const parseResult = parser.parse(yamlContent, filePath);\r\n  const errors = parser.getErrors();\r\n\r\n  // Separate errors and warnings\r\n  for (const issue of errors) {\r\n    if (issue.severity === 'error') {\r\n      result.errors.push(issue);\r\n    } else if (issue.severity === 'warning') {\r\n      result.warnings.push(issue);\r\n    } else {\r\n      result.info.push(issue);\r\n    }\r\n  }\r\n\r\n  if (parseResult) {\r\n    result.itemCount = parseResult.schemas.size;\r\n\r\n    // Add info about parsed schemas\r\n    result.info.push(\r\n      createIssue(\r\n        'SCHEMAS_PARSED',\r\n        `Successfully parsed ${parseResult.schemas.size} schema(s): ${Array.from(parseResult.schemas.keys()).join(', ')}`,\r\n        'info',\r\n        { filePath }\r\n      )\r\n    );\r\n\r\n    // Add info about inheritance\r\n    if (parseResult.relationships.length > 0) {\r\n      result.info.push(\r\n        createIssue(\r\n          'INHERITANCE_RESOLVED',\r\n          `Resolved ${parseResult.relationships.length} inheritance relationship(s)`,\r\n          'info',\r\n          { filePath }\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  result.valid = result.errors.length === 0;\r\n  result.duration = Date.now() - startTime;\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Validate Schema DSL from a file\r\n *\r\n * @param filePath - Path to the YAML file\r\n * @returns ValidationResult with errors, warnings, and info\r\n */\r\nexport async function validateSchemaDSLFile(\r\n  filePath: string\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n\r\n  if (!(await fileExists(filePath))) {\r\n    const result = createEmptyResult();\r\n    result.errors.push(\r\n      createIssue('FILE_NOT_FOUND', `Schema DSL file not found: ${filePath}`, 'error', {\r\n        filePath,\r\n      })\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n\r\n  try {\r\n    const content = await readTextFile(filePath);\r\n    return validateSchemaDSL(content, filePath);\r\n  } catch (error) {\r\n    const result = createEmptyResult();\r\n    result.errors.push(\r\n      createIssue(\r\n        'FILE_READ_ERROR',\r\n        `Failed to read Schema DSL file: ${error instanceof Error ? error.message : String(error)}`,\r\n        'error',\r\n        { filePath }\r\n      )\r\n    );\r\n    result.valid = false;\r\n    result.duration = Date.now() - startTime;\r\n    return result;\r\n  }\r\n}\r\n\r\n/**\r\n * Default export\r\n */\r\nexport default SchemaDSLParser;\r\n","/**\r\n * PKF Validator\r\n * Main entry point for validation functions\r\n */\r\n\r\nexport * from './types/index.js';\r\nexport * from './validators/index.js';\r\nexport * from './parsers/index.js';\r\n\r\nimport {\r\n  type ValidationResult,\r\n  type ValidationOptions,\r\n  createEmptyResult,\r\n  mergeResults,\r\n} from './types/index.js';\r\nimport { validateConfig } from './validators/config-validator.js';\r\nimport { validateTodo } from './validators/todo-validator.js';\r\nimport { validateIssues } from './validators/issue-validator.js';\r\nimport { validateChangelog } from './validators/changelog-validator.js';\r\nimport { fileExists, getRegistersPath } from './utils/file-utils.js';\r\nimport { join } from 'path';\r\n\r\n/**\r\n * Options for validateAll\r\n */\r\nexport interface ValidateAllOptions extends ValidationOptions {\r\n  /** Skip config validation */\r\n  skipConfig?: boolean;\r\n  /** Skip TODO validation */\r\n  skipTodo?: boolean;\r\n  /** Skip Issues validation */\r\n  skipIssues?: boolean;\r\n  /** Skip Changelog validation */\r\n  skipChangelog?: boolean;\r\n}\r\n\r\n/**\r\n * Run all validators\r\n */\r\nexport async function validateAll(\r\n  options: ValidateAllOptions = {}\r\n): Promise<ValidationResult> {\r\n  const startTime = Date.now();\r\n  const rootDir = options.rootDir || process.cwd();\r\n  const registersPath = getRegistersPath(rootDir);\r\n\r\n  const results: ValidationResult[] = [];\r\n  let itemCount = 0;\r\n\r\n  // Validate config\r\n  if (!options.skipConfig) {\r\n    const configPath = join(rootDir, 'pkf.config.yaml');\r\n    if (await fileExists(configPath)) {\r\n      const configResult = await validateConfig({ ...options, rootDir });\r\n      results.push(configResult);\r\n      itemCount++;\r\n    }\r\n  }\r\n\r\n  // Validate TODO\r\n  if (!options.skipTodo) {\r\n    const todoPath = join(registersPath, 'TODO.md');\r\n    if (await fileExists(todoPath)) {\r\n      const todoResult = await validateTodo(todoPath, options);\r\n      results.push(todoResult);\r\n      itemCount += todoResult.itemCount ?? 1;\r\n    }\r\n  }\r\n\r\n  // Validate Issues\r\n  if (!options.skipIssues) {\r\n    const issuesPath = join(registersPath, 'ISSUES.md');\r\n    if (await fileExists(issuesPath)) {\r\n      const issuesResult = await validateIssues(issuesPath, options);\r\n      results.push(issuesResult);\r\n      itemCount += issuesResult.itemCount ?? 1;\r\n    }\r\n  }\r\n\r\n  // Validate Changelog\r\n  if (!options.skipChangelog) {\r\n    const changelogPath = join(registersPath, 'CHANGELOG.md');\r\n    if (await fileExists(changelogPath)) {\r\n      const changelogResult = await validateChangelog(changelogPath, options);\r\n      results.push(changelogResult);\r\n      itemCount += changelogResult.itemCount ?? 1;\r\n    }\r\n  }\r\n\r\n  // Merge all results\r\n  const merged = results.length > 0 ? mergeResults(...results) : createEmptyResult();\r\n  merged.duration = Date.now() - startTime;\r\n  merged.itemCount = itemCount;\r\n\r\n  return merged;\r\n}\r\n"],"mappings":"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","names":["join","join","resolve","dirname","resolve","dirname","fileURLToPath","parseYaml","getDefaultSchemaPath","dirname","fileURLToPath","resolve","parseYaml","readFile","resolve","isValidDate","parseYaml","resolve","readFile","parseIssues","parseYaml","parseYaml","categorizeIssues","isValidDate","parseYaml","parseYaml","join"]}