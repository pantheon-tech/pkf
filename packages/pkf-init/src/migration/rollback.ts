/**
 * PKF Init Rollback Manager
 * Provides rollback functionality to restore from backups
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import type { WorkflowStateManager } from '../state/workflow-state.js';
import type { LoadedConfig } from '../types/index.js';
import logger from '../utils/logger.js';

/**
 * Result of a rollback operation
 */
export interface RollbackResult {
  /** Whether rollback succeeded */
  success: boolean;
  /** List of files that were removed */
  removedFiles: string[];
  /** List of files that were restored */
  restoredFiles: string[];
  /** Error message if rollback failed */
  error?: string;
}

/**
 * Files generated by PKF that should be removed during rollback
 */
const PKF_GENERATED_FILES = [
  'pkf.config.yaml',
];

/**
 * Directories generated by PKF that should be removed during rollback
 */
const PKF_GENERATED_DIRS = [
  'schemas',
];

/**
 * RollbackManager handles reverting PKF initialization changes
 */
export class RollbackManager {
  private config: LoadedConfig;
  private stateManager: WorkflowStateManager;

  /**
   * Create a new RollbackManager
   * @param config - Loaded configuration
   * @param stateManager - Workflow state manager
   */
  constructor(config: LoadedConfig, stateManager: WorkflowStateManager) {
    this.config = config;
    this.stateManager = stateManager;
  }

  /**
   * Perform rollback operation
   * @param backupPath - Path to backup directory
   * @returns Rollback result
   */
  async rollback(backupPath: string): Promise<RollbackResult> {
    logger.stage('Rollback');

    try {
      // Step 1: Verify backup exists
      logger.step('Verifying backup...');
      const backupExists = await this.verifyBackup(backupPath);

      if (!backupExists) {
        return {
          success: false,
          removedFiles: [],
          restoredFiles: [],
          error: `Backup not found at: ${backupPath}`,
        };
      }

      logger.info(`Backup verified at: ${backupPath}`);

      // Step 2: Remove generated PKF files
      logger.step('Removing generated files...');
      const removedFiles = await this.removeGeneratedFiles();
      logger.info(`Removed ${removedFiles.length} generated files/directories`);

      // Step 3: Restore from backup
      logger.step('Restoring from backup...');
      const restoredFiles = await this.restoreFromBackup(backupPath);
      logger.info(`Restored ${restoredFiles.length} files`);

      // Step 4: Clear workflow state
      logger.step('Clearing workflow state...');
      await this.stateManager.clear();
      logger.info('Workflow state cleared');

      logger.success('Rollback completed successfully');

      return {
        success: true,
        removedFiles,
        restoredFiles,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Rollback failed: ${errorMessage}`);

      return {
        success: false,
        removedFiles: [],
        restoredFiles: [],
        error: errorMessage,
      };
    }
  }

  /**
   * Verify that backup exists and is valid
   * @param backupPath - Path to backup directory
   * @returns True if backup exists and is valid
   */
  private async verifyBackup(backupPath: string): Promise<boolean> {
    try {
      const stats = await fs.stat(backupPath);
      return stats.isDirectory();
    } catch {
      return false;
    }
  }

  /**
   * Remove files and directories generated by PKF
   * @returns List of removed file/directory paths
   */
  private async removeGeneratedFiles(): Promise<string[]> {
    const removed: string[] = [];

    // Remove generated files in root directory
    for (const fileName of PKF_GENERATED_FILES) {
      const filePath = path.join(this.config.rootDir, fileName);
      const wasRemoved = await this.removeFile(filePath);
      if (wasRemoved) {
        removed.push(filePath);
      }
    }

    // Remove generated directories
    for (const dirName of PKF_GENERATED_DIRS) {
      const dirPath = path.join(this.config.outputDir, dirName);
      const wasRemoved = await this.removeDirectory(dirPath);
      if (wasRemoved) {
        removed.push(dirPath);
      }
    }

    // Remove registers if they were created by PKF (not pre-existing)
    // We check the workflow state to determine this
    const state = await this.stateManager.load();
    if (state?.implementation?.createdFiles) {
      for (const filePath of state.implementation.createdFiles) {
        const wasRemoved = await this.removeFile(filePath);
        if (wasRemoved) {
          removed.push(filePath);
        }
      }
    }

    // Remove created directories from implementation stage
    if (state?.implementation?.createdDirs) {
      // Sort directories by depth (deepest first) to remove children before parents
      const sortedDirs = [...state.implementation.createdDirs].sort((a, b) => {
        return b.split(path.sep).length - a.split(path.sep).length;
      });

      for (const dirPath of sortedDirs) {
        const wasRemoved = await this.removeEmptyDirectory(dirPath);
        if (wasRemoved) {
          removed.push(dirPath);
        }
      }
    }

    return removed;
  }

  /**
   * Remove a single file
   * @param filePath - Path to file
   * @returns True if file was removed
   */
  private async removeFile(filePath: string): Promise<boolean> {
    try {
      await fs.unlink(filePath);
      logger.debug(`Removed file: ${filePath}`);
      return true;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        // File doesn't exist, nothing to remove
        return false;
      }
      logger.warn(`Failed to remove file: ${filePath}`);
      return false;
    }
  }

  /**
   * Remove a directory and all its contents
   * @param dirPath - Path to directory
   * @returns True if directory was removed
   */
  private async removeDirectory(dirPath: string): Promise<boolean> {
    try {
      await fs.rm(dirPath, { recursive: true, force: true });
      logger.debug(`Removed directory: ${dirPath}`);
      return true;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        // Directory doesn't exist, nothing to remove
        return false;
      }
      logger.warn(`Failed to remove directory: ${dirPath}`);
      return false;
    }
  }

  /**
   * Remove an empty directory only
   * @param dirPath - Path to directory
   * @returns True if directory was removed
   */
  private async removeEmptyDirectory(dirPath: string): Promise<boolean> {
    try {
      // Check if directory is empty
      const entries = await fs.readdir(dirPath);
      if (entries.length > 0) {
        logger.debug(`Directory not empty, skipping: ${dirPath}`);
        return false;
      }

      await fs.rmdir(dirPath);
      logger.debug(`Removed empty directory: ${dirPath}`);
      return true;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return false;
      }
      if ((error as NodeJS.ErrnoException).code === 'ENOTEMPTY') {
        logger.debug(`Directory not empty: ${dirPath}`);
        return false;
      }
      logger.warn(`Failed to remove directory: ${dirPath}`);
      return false;
    }
  }

  /**
   * Restore files from backup to original locations
   * @param backupPath - Path to backup directory
   * @returns List of restored file paths
   */
  private async restoreFromBackup(backupPath: string): Promise<string[]> {
    const restored: string[] = [];

    // Get the target directory (docs directory)
    const targetDir = this.config.docsDir;

    // Recursively copy files from backup to target
    await this.copyDirectory(backupPath, targetDir, restored);

    return restored;
  }

  /**
   * Recursively copy a directory
   * @param src - Source directory
   * @param dest - Destination directory
   * @param restored - Array to track restored files
   */
  private async copyDirectory(
    src: string,
    dest: string,
    restored: string[]
  ): Promise<void> {
    // Create destination directory
    await fs.mkdir(dest, { recursive: true });

    // Read source directory entries
    const entries = await fs.readdir(src, { withFileTypes: true });

    for (const entry of entries) {
      const srcPath = path.join(src, entry.name);
      const destPath = path.join(dest, entry.name);

      if (entry.isDirectory()) {
        // Recursively copy subdirectory
        await this.copyDirectory(srcPath, destPath, restored);
      } else {
        // Copy file
        await fs.copyFile(srcPath, destPath);
        restored.push(destPath);
        logger.debug(`Restored: ${destPath}`);
      }
    }
  }

  /**
   * Get the latest backup path if available
   * @returns Latest backup path or null if none found
   */
  async getLatestBackup(): Promise<string | null> {
    try {
      const backupDir = this.config.backupDir;

      // Check if backup directory exists
      try {
        await fs.access(backupDir);
      } catch {
        return null;
      }

      // List backup directories
      const entries = await fs.readdir(backupDir, { withFileTypes: true });
      const backups = entries
        .filter((e) => e.isDirectory() && e.name.startsWith('docs-'))
        .map((e) => ({
          name: e.name,
          path: path.join(backupDir, e.name),
        }));

      if (backups.length === 0) {
        return null;
      }

      // Sort by name (which includes timestamp) descending
      backups.sort((a, b) => b.name.localeCompare(a.name));

      return backups[0].path;
    } catch {
      return null;
    }
  }

  /**
   * List all available backups
   * @returns List of backup paths with timestamps
   */
  async listBackups(): Promise<Array<{ path: string; timestamp: string }>> {
    try {
      const backupDir = this.config.backupDir;

      // Check if backup directory exists
      try {
        await fs.access(backupDir);
      } catch {
        return [];
      }

      // List backup directories
      const entries = await fs.readdir(backupDir, { withFileTypes: true });
      const backups = entries
        .filter((e) => e.isDirectory() && e.name.startsWith('docs-'))
        .map((e) => {
          // Extract timestamp from directory name (docs-YYYY-MM-DDTHH-MM-SS-sssZ)
          const timestamp = e.name.replace('docs-', '').replace(/-/g, (match, offset) => {
            // Convert back to ISO format
            if (offset === 4 || offset === 7) return '-';
            if (offset === 10) return 'T';
            if (offset === 13 || offset === 16) return ':';
            if (offset === 19) return '.';
            return match;
          });

          return {
            path: path.join(backupDir, e.name),
            timestamp,
          };
        });

      // Sort by timestamp descending
      backups.sort((a, b) => b.timestamp.localeCompare(a.timestamp));

      return backups;
    } catch {
      return [];
    }
  }
}

export default RollbackManager;
