/**
 * PKF Init Rollback Manager
 * Provides rollback functionality to restore from backups and reverse migrations
 */
import * as fs from 'fs/promises';
import * as path from 'path';
import logger from '../utils/logger.js';
/**
 * Files generated by PKF that should be removed during rollback
 */
const PKF_GENERATED_FILES = [
    'pkf.config.yaml',
];
/**
 * Directories generated by PKF that should be removed during rollback
 */
const PKF_GENERATED_DIRS = [
    'schemas',
];
/**
 * RollbackManager handles reverting PKF initialization changes
 */
export class RollbackManager {
    config;
    stateManager;
    /**
     * Create a new RollbackManager
     * @param config - Loaded configuration
     * @param stateManager - Workflow state manager
     */
    constructor(config, stateManager) {
        this.config = config;
        this.stateManager = stateManager;
    }
    /**
     * Perform rollback operation using backup
     * @param backupPath - Path to backup directory
     * @returns Rollback result
     */
    async rollback(backupPath) {
        logger.stage('Rollback');
        try {
            // Step 1: Verify backup exists
            logger.step('Verifying backup...');
            const backupExists = await this.verifyBackup(backupPath);
            if (!backupExists) {
                return {
                    success: false,
                    removedFiles: [],
                    restoredFiles: [],
                    movedBack: [],
                    operationsRolledBack: 0,
                    error: `Backup not found at: ${backupPath}`,
                };
            }
            logger.info(`Backup verified at: ${backupPath}`);
            // Step 2: Remove generated PKF files
            logger.step('Removing generated files...');
            const removedFiles = await this.removeGeneratedFiles();
            logger.info(`Removed ${removedFiles.length} generated files/directories`);
            // Step 3: Restore from backup
            logger.step('Restoring from backup...');
            const restoredFiles = await this.restoreFromBackup(backupPath);
            logger.info(`Restored ${restoredFiles.length} files`);
            // Step 4: Clear workflow state
            logger.step('Clearing workflow state...');
            await this.stateManager.clear();
            logger.info('Workflow state cleared');
            logger.success('Rollback completed successfully');
            return {
                success: true,
                removedFiles,
                restoredFiles,
                movedBack: [],
                operationsRolledBack: 0,
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            logger.error(`Rollback failed: ${errorMessage}`);
            return {
                success: false,
                removedFiles: [],
                restoredFiles: [],
                movedBack: [],
                operationsRolledBack: 0,
                error: errorMessage,
            };
        }
    }
    /**
     * Rollback migration operations in reverse order
     * This reverses the effects of file moves, writes, and deletes
     *
     * @param operations - List of operations to rollback (in original order)
     * @param backupPath - Optional backup path for content restoration
     * @returns Rollback result
     */
    async rollbackOperations(operations, backupPath) {
        logger.stage('Rollback Operations');
        const removedFiles = [];
        const restoredFiles = [];
        const movedBack = [];
        let operationsRolledBack = 0;
        try {
            // Reverse the operations list to undo in correct order
            const reversedOps = [...operations].reverse();
            for (const op of reversedOps) {
                // Skip failed operations - nothing to rollback
                if (op.status === 'failed') {
                    continue;
                }
                try {
                    switch (op.type) {
                        case 'write':
                            // Undo a write by deleting the file
                            // If we have a backup, we'll restore original content later
                            await this.removeFile(op.sourcePath);
                            removedFiles.push(op.sourcePath);
                            operationsRolledBack++;
                            logger.debug(`Rolled back write: ${op.sourcePath}`);
                            break;
                        case 'delete':
                            // Undo a delete by restoring from backup
                            if (backupPath) {
                                const restored = await this.restoreFileFromBackup(op.sourcePath, backupPath);
                                if (restored) {
                                    restoredFiles.push(op.sourcePath);
                                    operationsRolledBack++;
                                    logger.debug(`Restored deleted file: ${op.sourcePath}`);
                                }
                            }
                            else {
                                logger.warn(`Cannot restore ${op.sourcePath} - no backup available`);
                            }
                            break;
                        case 'move':
                            // Undo a move by moving back to original location
                            if (op.targetPath) {
                                const moved = await this.moveFileBack(op.targetPath, op.sourcePath);
                                if (moved) {
                                    movedBack.push(op.sourcePath);
                                    operationsRolledBack++;
                                    logger.debug(`Moved back: ${op.targetPath} -> ${op.sourcePath}`);
                                }
                            }
                            break;
                        case 'copy':
                            // Undo a copy by removing the target and restoring source if deleted
                            if (op.targetPath) {
                                await this.removeFile(op.targetPath);
                                removedFiles.push(op.targetPath);
                                operationsRolledBack++;
                            }
                            break;
                        case 'update_reference':
                            // Reference updates are handled by restoring original content from backup
                            // The write rollback above handles this
                            break;
                        default:
                            logger.warn(`Unknown operation type: ${op.type}`);
                    }
                }
                catch (error) {
                    logger.warn(`Failed to rollback operation: ${error instanceof Error ? error.message : String(error)}`);
                    // Continue with other operations
                }
            }
            // Restore any deleted source files from backup
            if (backupPath && restoredFiles.length === 0) {
                logger.step('Restoring from backup...');
                const restored = await this.restoreFromBackup(backupPath);
                restoredFiles.push(...restored);
            }
            logger.success(`Rollback completed: ${operationsRolledBack} operations reversed`);
            return {
                success: true,
                removedFiles,
                restoredFiles,
                movedBack,
                operationsRolledBack,
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            logger.error(`Operation rollback failed: ${errorMessage}`);
            return {
                success: false,
                removedFiles,
                restoredFiles,
                movedBack,
                operationsRolledBack,
                error: errorMessage,
            };
        }
    }
    /**
     * Move a file back to its original location
     * @param currentPath - Current file path
     * @param originalPath - Original file path
     * @returns True if move was successful
     */
    async moveFileBack(currentPath, originalPath) {
        try {
            const absoluteCurrent = path.isAbsolute(currentPath)
                ? currentPath
                : path.join(this.config.rootDir, currentPath);
            const absoluteOriginal = path.isAbsolute(originalPath)
                ? originalPath
                : path.join(this.config.rootDir, originalPath);
            // Check current file exists
            try {
                await fs.access(absoluteCurrent);
            }
            catch {
                logger.debug(`Source file not found for move back: ${currentPath}`);
                return false;
            }
            // Create parent directory for original location
            const parentDir = path.dirname(absoluteOriginal);
            await fs.mkdir(parentDir, { recursive: true });
            // Move file back
            await fs.rename(absoluteCurrent, absoluteOriginal);
            return true;
        }
        catch {
            logger.warn(`Failed to move file back: ${currentPath} -> ${originalPath}`);
            return false;
        }
    }
    /**
     * Restore a single file from backup
     * @param filePath - Relative file path
     * @param backupPath - Path to backup directory
     * @returns True if file was restored
     */
    async restoreFileFromBackup(filePath, backupPath) {
        try {
            const relativePath = path.isAbsolute(filePath)
                ? path.relative(this.config.rootDir, filePath)
                : filePath;
            const backupFilePath = path.join(backupPath, relativePath);
            const targetPath = path.join(this.config.rootDir, relativePath);
            // Check backup file exists
            try {
                await fs.access(backupFilePath);
            }
            catch {
                logger.debug(`Backup file not found: ${backupFilePath}`);
                return false;
            }
            // Create parent directory
            const parentDir = path.dirname(targetPath);
            await fs.mkdir(parentDir, { recursive: true });
            // Copy from backup
            await fs.copyFile(backupFilePath, targetPath);
            return true;
        }
        catch {
            logger.warn(`Failed to restore file from backup: ${filePath}`);
            return false;
        }
    }
    /**
     * Verify that backup exists and is valid
     * @param backupPath - Path to backup directory
     * @returns True if backup exists and is valid
     */
    async verifyBackup(backupPath) {
        try {
            const stats = await fs.stat(backupPath);
            return stats.isDirectory();
        }
        catch {
            return false;
        }
    }
    /**
     * Remove files and directories generated by PKF
     * @returns List of removed file/directory paths
     */
    async removeGeneratedFiles() {
        const removed = [];
        // Remove generated files in root directory
        for (const fileName of PKF_GENERATED_FILES) {
            const filePath = path.join(this.config.rootDir, fileName);
            const wasRemoved = await this.removeFile(filePath);
            if (wasRemoved) {
                removed.push(filePath);
            }
        }
        // Remove generated directories
        for (const dirName of PKF_GENERATED_DIRS) {
            const dirPath = path.join(this.config.outputDir, dirName);
            const wasRemoved = await this.removeDirectory(dirPath);
            if (wasRemoved) {
                removed.push(dirPath);
            }
        }
        // Remove registers if they were created by PKF (not pre-existing)
        // We check the workflow state to determine this
        const state = await this.stateManager.load();
        if (state?.implementation?.createdFiles) {
            for (const filePath of state.implementation.createdFiles) {
                const wasRemoved = await this.removeFile(filePath);
                if (wasRemoved) {
                    removed.push(filePath);
                }
            }
        }
        // Remove created directories from implementation stage
        if (state?.implementation?.createdDirs) {
            // Sort directories by depth (deepest first) to remove children before parents
            const sortedDirs = [...state.implementation.createdDirs].sort((a, b) => {
                return b.split(path.sep).length - a.split(path.sep).length;
            });
            for (const dirPath of sortedDirs) {
                const wasRemoved = await this.removeEmptyDirectory(dirPath);
                if (wasRemoved) {
                    removed.push(dirPath);
                }
            }
        }
        return removed;
    }
    /**
     * Remove a single file
     * @param filePath - Path to file
     * @returns True if file was removed
     */
    async removeFile(filePath) {
        try {
            await fs.unlink(filePath);
            logger.debug(`Removed file: ${filePath}`);
            return true;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // File doesn't exist, nothing to remove
                return false;
            }
            logger.warn(`Failed to remove file: ${filePath}`);
            return false;
        }
    }
    /**
     * Remove a directory and all its contents
     * @param dirPath - Path to directory
     * @returns True if directory was removed
     */
    async removeDirectory(dirPath) {
        try {
            await fs.rm(dirPath, { recursive: true, force: true });
            logger.debug(`Removed directory: ${dirPath}`);
            return true;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // Directory doesn't exist, nothing to remove
                return false;
            }
            logger.warn(`Failed to remove directory: ${dirPath}`);
            return false;
        }
    }
    /**
     * Remove an empty directory only
     * @param dirPath - Path to directory
     * @returns True if directory was removed
     */
    async removeEmptyDirectory(dirPath) {
        try {
            // Check if directory is empty
            const entries = await fs.readdir(dirPath);
            if (entries.length > 0) {
                logger.debug(`Directory not empty, skipping: ${dirPath}`);
                return false;
            }
            await fs.rmdir(dirPath);
            logger.debug(`Removed empty directory: ${dirPath}`);
            return true;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return false;
            }
            if (error.code === 'ENOTEMPTY') {
                logger.debug(`Directory not empty: ${dirPath}`);
                return false;
            }
            logger.warn(`Failed to remove directory: ${dirPath}`);
            return false;
        }
    }
    /**
     * Restore files from backup to original locations
     * @param backupPath - Path to backup directory
     * @returns List of restored file paths
     */
    async restoreFromBackup(backupPath) {
        const restored = [];
        // Get the target directory (docs directory)
        const targetDir = this.config.docsDir;
        // Recursively copy files from backup to target
        await this.copyDirectory(backupPath, targetDir, restored);
        return restored;
    }
    /**
     * Recursively copy a directory
     * @param src - Source directory
     * @param dest - Destination directory
     * @param restored - Array to track restored files
     */
    async copyDirectory(src, dest, restored) {
        // Create destination directory
        await fs.mkdir(dest, { recursive: true });
        // Read source directory entries
        const entries = await fs.readdir(src, { withFileTypes: true });
        for (const entry of entries) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            if (entry.isDirectory()) {
                // Recursively copy subdirectory
                await this.copyDirectory(srcPath, destPath, restored);
            }
            else {
                // Copy file
                await fs.copyFile(srcPath, destPath);
                restored.push(destPath);
                logger.debug(`Restored: ${destPath}`);
            }
        }
    }
    /**
     * Get the latest backup path if available
     * @returns Latest backup path or null if none found
     */
    async getLatestBackup() {
        try {
            const backupDir = this.config.backupDir;
            // Check if backup directory exists
            try {
                await fs.access(backupDir);
            }
            catch {
                return null;
            }
            // List backup directories
            const entries = await fs.readdir(backupDir, { withFileTypes: true });
            const backups = entries
                .filter((e) => e.isDirectory() && e.name.startsWith('docs-'))
                .map((e) => ({
                name: e.name,
                path: path.join(backupDir, e.name),
            }));
            if (backups.length === 0) {
                return null;
            }
            // Sort by name (which includes timestamp) descending
            backups.sort((a, b) => b.name.localeCompare(a.name));
            return backups[0].path;
        }
        catch {
            return null;
        }
    }
    /**
     * List all available backups
     * @returns List of backup paths with timestamps
     */
    async listBackups() {
        try {
            const backupDir = this.config.backupDir;
            // Check if backup directory exists
            try {
                await fs.access(backupDir);
            }
            catch {
                return [];
            }
            // List backup directories
            const entries = await fs.readdir(backupDir, { withFileTypes: true });
            const backups = entries
                .filter((e) => e.isDirectory() && e.name.startsWith('docs-'))
                .map((e) => {
                // Extract timestamp from directory name (docs-YYYY-MM-DDTHH-MM-SS-sssZ)
                const timestamp = e.name.replace('docs-', '').replace(/-/g, (match, offset) => {
                    // Convert back to ISO format
                    if (offset === 4 || offset === 7)
                        return '-';
                    if (offset === 10)
                        return 'T';
                    if (offset === 13 || offset === 16)
                        return ':';
                    if (offset === 19)
                        return '.';
                    return match;
                });
                return {
                    path: path.join(backupDir, e.name),
                    timestamp,
                };
            });
            // Sort by timestamp descending
            backups.sort((a, b) => b.timestamp.localeCompare(a.timestamp));
            return backups;
        }
        catch {
            return [];
        }
    }
}
export default RollbackManager;
//# sourceMappingURL=rollback.js.map