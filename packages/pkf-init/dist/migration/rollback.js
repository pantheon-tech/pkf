/**
 * PKF Init Rollback Manager
 * Provides rollback functionality to restore from backups
 */
import * as fs from 'fs/promises';
import * as path from 'path';
import logger from '../utils/logger.js';
/**
 * Files generated by PKF that should be removed during rollback
 */
const PKF_GENERATED_FILES = [
    'pkf.config.yaml',
];
/**
 * Directories generated by PKF that should be removed during rollback
 */
const PKF_GENERATED_DIRS = [
    'schemas',
];
/**
 * RollbackManager handles reverting PKF initialization changes
 */
export class RollbackManager {
    config;
    stateManager;
    /**
     * Create a new RollbackManager
     * @param config - Loaded configuration
     * @param stateManager - Workflow state manager
     */
    constructor(config, stateManager) {
        this.config = config;
        this.stateManager = stateManager;
    }
    /**
     * Perform rollback operation
     * @param backupPath - Path to backup directory
     * @returns Rollback result
     */
    async rollback(backupPath) {
        logger.stage('Rollback');
        try {
            // Step 1: Verify backup exists
            logger.step('Verifying backup...');
            const backupExists = await this.verifyBackup(backupPath);
            if (!backupExists) {
                return {
                    success: false,
                    removedFiles: [],
                    restoredFiles: [],
                    error: `Backup not found at: ${backupPath}`,
                };
            }
            logger.info(`Backup verified at: ${backupPath}`);
            // Step 2: Remove generated PKF files
            logger.step('Removing generated files...');
            const removedFiles = await this.removeGeneratedFiles();
            logger.info(`Removed ${removedFiles.length} generated files/directories`);
            // Step 3: Restore from backup
            logger.step('Restoring from backup...');
            const restoredFiles = await this.restoreFromBackup(backupPath);
            logger.info(`Restored ${restoredFiles.length} files`);
            // Step 4: Clear workflow state
            logger.step('Clearing workflow state...');
            await this.stateManager.clear();
            logger.info('Workflow state cleared');
            logger.success('Rollback completed successfully');
            return {
                success: true,
                removedFiles,
                restoredFiles,
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            logger.error(`Rollback failed: ${errorMessage}`);
            return {
                success: false,
                removedFiles: [],
                restoredFiles: [],
                error: errorMessage,
            };
        }
    }
    /**
     * Verify that backup exists and is valid
     * @param backupPath - Path to backup directory
     * @returns True if backup exists and is valid
     */
    async verifyBackup(backupPath) {
        try {
            const stats = await fs.stat(backupPath);
            return stats.isDirectory();
        }
        catch {
            return false;
        }
    }
    /**
     * Remove files and directories generated by PKF
     * @returns List of removed file/directory paths
     */
    async removeGeneratedFiles() {
        const removed = [];
        // Remove generated files in root directory
        for (const fileName of PKF_GENERATED_FILES) {
            const filePath = path.join(this.config.rootDir, fileName);
            const wasRemoved = await this.removeFile(filePath);
            if (wasRemoved) {
                removed.push(filePath);
            }
        }
        // Remove generated directories
        for (const dirName of PKF_GENERATED_DIRS) {
            const dirPath = path.join(this.config.outputDir, dirName);
            const wasRemoved = await this.removeDirectory(dirPath);
            if (wasRemoved) {
                removed.push(dirPath);
            }
        }
        // Remove registers if they were created by PKF (not pre-existing)
        // We check the workflow state to determine this
        const state = await this.stateManager.load();
        if (state?.implementation?.createdFiles) {
            for (const filePath of state.implementation.createdFiles) {
                const wasRemoved = await this.removeFile(filePath);
                if (wasRemoved) {
                    removed.push(filePath);
                }
            }
        }
        // Remove created directories from implementation stage
        if (state?.implementation?.createdDirs) {
            // Sort directories by depth (deepest first) to remove children before parents
            const sortedDirs = [...state.implementation.createdDirs].sort((a, b) => {
                return b.split(path.sep).length - a.split(path.sep).length;
            });
            for (const dirPath of sortedDirs) {
                const wasRemoved = await this.removeEmptyDirectory(dirPath);
                if (wasRemoved) {
                    removed.push(dirPath);
                }
            }
        }
        return removed;
    }
    /**
     * Remove a single file
     * @param filePath - Path to file
     * @returns True if file was removed
     */
    async removeFile(filePath) {
        try {
            await fs.unlink(filePath);
            logger.debug(`Removed file: ${filePath}`);
            return true;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // File doesn't exist, nothing to remove
                return false;
            }
            logger.warn(`Failed to remove file: ${filePath}`);
            return false;
        }
    }
    /**
     * Remove a directory and all its contents
     * @param dirPath - Path to directory
     * @returns True if directory was removed
     */
    async removeDirectory(dirPath) {
        try {
            await fs.rm(dirPath, { recursive: true, force: true });
            logger.debug(`Removed directory: ${dirPath}`);
            return true;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // Directory doesn't exist, nothing to remove
                return false;
            }
            logger.warn(`Failed to remove directory: ${dirPath}`);
            return false;
        }
    }
    /**
     * Remove an empty directory only
     * @param dirPath - Path to directory
     * @returns True if directory was removed
     */
    async removeEmptyDirectory(dirPath) {
        try {
            // Check if directory is empty
            const entries = await fs.readdir(dirPath);
            if (entries.length > 0) {
                logger.debug(`Directory not empty, skipping: ${dirPath}`);
                return false;
            }
            await fs.rmdir(dirPath);
            logger.debug(`Removed empty directory: ${dirPath}`);
            return true;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                return false;
            }
            if (error.code === 'ENOTEMPTY') {
                logger.debug(`Directory not empty: ${dirPath}`);
                return false;
            }
            logger.warn(`Failed to remove directory: ${dirPath}`);
            return false;
        }
    }
    /**
     * Restore files from backup to original locations
     * @param backupPath - Path to backup directory
     * @returns List of restored file paths
     */
    async restoreFromBackup(backupPath) {
        const restored = [];
        // Get the target directory (docs directory)
        const targetDir = this.config.docsDir;
        // Recursively copy files from backup to target
        await this.copyDirectory(backupPath, targetDir, restored);
        return restored;
    }
    /**
     * Recursively copy a directory
     * @param src - Source directory
     * @param dest - Destination directory
     * @param restored - Array to track restored files
     */
    async copyDirectory(src, dest, restored) {
        // Create destination directory
        await fs.mkdir(dest, { recursive: true });
        // Read source directory entries
        const entries = await fs.readdir(src, { withFileTypes: true });
        for (const entry of entries) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            if (entry.isDirectory()) {
                // Recursively copy subdirectory
                await this.copyDirectory(srcPath, destPath, restored);
            }
            else {
                // Copy file
                await fs.copyFile(srcPath, destPath);
                restored.push(destPath);
                logger.debug(`Restored: ${destPath}`);
            }
        }
    }
    /**
     * Get the latest backup path if available
     * @returns Latest backup path or null if none found
     */
    async getLatestBackup() {
        try {
            const backupDir = this.config.backupDir;
            // Check if backup directory exists
            try {
                await fs.access(backupDir);
            }
            catch {
                return null;
            }
            // List backup directories
            const entries = await fs.readdir(backupDir, { withFileTypes: true });
            const backups = entries
                .filter((e) => e.isDirectory() && e.name.startsWith('docs-'))
                .map((e) => ({
                name: e.name,
                path: path.join(backupDir, e.name),
            }));
            if (backups.length === 0) {
                return null;
            }
            // Sort by name (which includes timestamp) descending
            backups.sort((a, b) => b.name.localeCompare(a.name));
            return backups[0].path;
        }
        catch {
            return null;
        }
    }
    /**
     * List all available backups
     * @returns List of backup paths with timestamps
     */
    async listBackups() {
        try {
            const backupDir = this.config.backupDir;
            // Check if backup directory exists
            try {
                await fs.access(backupDir);
            }
            catch {
                return [];
            }
            // List backup directories
            const entries = await fs.readdir(backupDir, { withFileTypes: true });
            const backups = entries
                .filter((e) => e.isDirectory() && e.name.startsWith('docs-'))
                .map((e) => {
                // Extract timestamp from directory name (docs-YYYY-MM-DDTHH-MM-SS-sssZ)
                const timestamp = e.name.replace('docs-', '').replace(/-/g, (match, offset) => {
                    // Convert back to ISO format
                    if (offset === 4 || offset === 7)
                        return '-';
                    if (offset === 10)
                        return 'T';
                    if (offset === 13 || offset === 16)
                        return ':';
                    if (offset === 19)
                        return '.';
                    return match;
                });
                return {
                    path: path.join(backupDir, e.name),
                    timestamp,
                };
            });
            // Sort by timestamp descending
            backups.sort((a, b) => b.timestamp.localeCompare(a.timestamp));
            return backups;
        }
        catch {
            return [];
        }
    }
}
export default RollbackManager;
//# sourceMappingURL=rollback.js.map